{"meta":{"title":"DevJH","subtitle":"Writed by JH, IT Blog","description":"IT Blog","author":"Lee Jung Hoon","url":"https://lee-jung-hoon.github.io"},"pages":[],"posts":[{"title":"스프링 부트의 자동 환경설정(Auto Configuration)","slug":"programmin-springboot-study-005","date":"2019-04-21T02:58:16.000Z","updated":"2019-04-21T05:41:27.894Z","comments":true,"path":"2019/04/21/programmin-springboot-study-005/","link":"","permalink":"https://lee-jung-hoon.github.io/2019/04/21/programmin-springboot-study-005/","excerpt":"","text":"스프링 부트의 자동 환경설정기존에 많이 사용하는 스프링의 경우 MVC, AOP, JPA, JDBC 등 웹 어플리케이션 동작에 필요한 설정을 수동으로 진행해야했다. 새로운 프로젝트를 진행하면 이와 같은 설정을 다시 작성해야하는 불필요한 시간을 소비했다. 스프링 부트는 WEB, JPA, AOP등 다양한 설정을 자동으로 적용하도록 한다. 스프링과 스프링부트의 설정은 어떻게 다를까먼저 과거 스프링의 설정 방식을 살펴볼 필요가 있다. 1234... viewResolver.setPrefix(\"/WEB-INF/views/\"); viewResolver.setSurffix(\".jsp\");... 기존 스프링의 ViewResolver 설정은 이처럼 작성을 해줘야했다. 12345spring: mvc: view: prefix: /WEB-INF/views/ surffix: .jsp 스프링 부트는 YAML이나 Properties 파일을 통해 간단히 설정이 가능하다.(물론 Web Starter가 의존성 추가되어야 한다) 이로 인해 가질 수 있는 장점은 가독성과 반복된 설정이 줄어들 수 있다. 123456789@RestController@SpringBootApplicationpublic class DemoWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoWebApplication.class, args); &#125; ...&#125; 스프링 부트의 자동 환경설정 동작 방식을 알아보고자 한다.위 클래스는 스프링 부트를 기동하는 클래스이다. @SpringBootApplication은 스프링 부트를 실행하기 위한 필수 어노테이션이다.단순히 실행을 위한 어노테이션이라 생각할 수 있지만 그 내부에는 자동설정을 위한 어노테이션을 포함하고 있다. 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; ...&#125; 스프링 부트 Reference에는 자동설정을 위해서 @Configuration 클래스 내 @EnableAutoConfiguration 애노테이션을 추가하라고 설명하고 있다.(SpringBootConfiguration 어노테이션이 Configuration 어노테이션을 포함하고 있다.) 결론적으로 SpringBootApplication 어노테이션은 자동설정 사용을 위한 어노테이션까지 함께 담고 있다. 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; EnableAutoConfiguration은 AutoConfigurationImportSelector를 Import하고 있다. AutoConfigurationImportSelector는 자동 설정 기능을 담당한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class AutoConfigurationImportSelector implements DeferredImportSelector, ... &#123; ... @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry( autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); &#125; ... protected AutoConfigurationEntry getAutoConfigurationEntry( AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); &#125; ... protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; &#125;&#125; AutoConfigurationImportSelector는 selectImports 메소드를 통해 @Configuration 어노테이션이 설정된 클래스명을 로드한다. getAutoConfigurationEntry 메소드는 내부적으로 getCandidateConfigurations 메소드를 통해 spring.factories를 로드하여 설정파일에서 사용할 목록을 생성한다. 123456789101112131415161718# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition spring.factorie는 이와 같이 key&amp;value 형태로 클래스 목록을 담고 있다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING BOOT","slug":"PROGRAMMING/SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING-BOOT/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"SPRING BOOT","slug":"SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/tags/SPRING-BOOT/"}]},{"title":"스프링 부트 커스텀 프로퍼티를 이용한 환경 설정","slug":"programming-springboot-study-004","date":"2019-04-14T12:07:27.000Z","updated":"2019-04-21T02:27:54.664Z","comments":true,"path":"2019/04/14/programming-springboot-study-004/","link":"","permalink":"https://lee-jung-hoon.github.io/2019/04/14/programming-springboot-study-004/","excerpt":"","text":"스프링 부트 커스텀 프로퍼티를 이용한 환경 설정스프링 부트는 기본적으로 application.properties 파일을 이용하여 어플리케이션의 환경설정을 관리한다. 스프링 부트 자체적으로 지원하는 프로퍼티도 있지만 개발을 진행하다보면 어플리케이션만의 프로퍼티가 필요하게 된다. 이러한 프로퍼티는 커스텀 프로퍼티를 이용하여 설정한다. 1. @Value를 이용한 바인딩@Value 어노테이션을 통한 프로퍼티 바인딩의 특징은 SpEL(Spring Expression Language)에 있다. SpEL에 대한 자세한 사항은 스프링 부트 레퍼런스를 참고한다. 1234567891011121314151617181920212223242526272829303132@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoConfigurationTest &#123; @Value(\"$&#123;demo.test.id&#125;\") private String demoId; @Value(\"#&#123;$&#123;demo.test.num&#125;-1&#125;\") private int demoNum; @Value(\"$&#123;demo.test.arr&#125;\") private String[] demoArr; @Value(\"#&#123;'$&#123;demo.test.arr&#125;'.split(',')&#125;\") private List&lt;String&gt; demoList; @Value(\"$&#123;demo.test.isUse&#125;\") private Boolean demoUse; @Test public void testValue() &#123; assertThat(demoId, is(\"propertyTest\")); assertThat(demoArr[0], is(\"react\")); assertThat(demoArr[1], is(\"vue\")); assertThat(demoArr[2], is(\"angular\")); assertThat(demoNum, is(-1)); assertThat(demoList.get(0), is(\"react\")); assertThat(demoList.get(1), is(\"vue\")); assertThat(demoList.get(2), is(\"angular\")); assertThat(demoUse, is(true)); &#125;&#125; 123456demo: test: id: propertyTest num: 0 arr: react,vue,angular isUse: true @Value(“${demo.test.id}”) @Value(“${demo.test.isUse}”) : 프로퍼티에 입력된 깊이에 따라 .(점)을 구분자로 값을 매핑한다. @Value(“${demo.test.arr}”) : 프로퍼티 데이터를 배열 형태로 매핑할 수 있다. @Value(“#{${demo.test.num}-1}”) @Value(“#{‘${demo.test.arr}’.split(‘,’)}”) : SpEL을 이용하여 연산을 하거나 데이터를 조합할 수 있다. 2. @ConfigurationProperties를 이용한 바인딩@ConfigurationProperties를 어노테이션을 통한 프로퍼티 바인딩의 특징에는유연한 바인딩(Relaxed binding)과 메타데이터 지원(Meta-data support)에 있다. ConfigurationProperties는 prefix(접두사)를 이용하여 바인당힌다. POJO 바인딩123name: firstName: lee lastName: junghoon 12345678910111213141516171819202122@Component@ConfigurationProperties(\"name\")public class Name &#123; private String firstName; private String lastName; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125;&#125; 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoConfigurationTest3 &#123; @Autowired private Name _name; @Test public void testValue() &#123; assertThat(_name.getFirstName(), is(\"lee\")); assertThat(_name.getLastName(), is(\"junghoon\")); &#125; ConfigurationProperties는 POJO 형태의 바인딩을 지원한다. 리스트 바인딩12345678database: list: - type: oracle name: sys - type: mysql name: root - type: postgreSQL name: admin 12345678910111213@Component@ConfigurationProperties(\"database\")public class DatabaseProperty &#123; private List&lt;Map&lt;String, String&gt;&gt; list; public List&lt;Map&lt;String, String&gt;&gt; getList() &#123; return list; &#125; public void setList(List&lt;Map&lt;String, String&gt;&gt; list) &#123; this.list = list; &#125;&#125; 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoConfigurationTest4 &#123; @Autowired private DatabaseProperty dataBaseProperty; @Test public void testValue() &#123; List&lt;Map&lt;String, String&gt;&gt; dataBaseList = dataBaseProperty.getList(); System.out.println(dataBaseList.get(0).get(\"type\")); System.out.println(dataBaseList.get(0).get(\"name\")); System.out.println(dataBaseList.get(1).get(\"type\")); System.out.println(dataBaseList.get(1).get(\"name\")); &#125;&#125; 또한 @configurationProperties은 유연한 바인딩을 지원한다. 123456@Component@ConfigurationProperties(\"name\")public class Name &#123; private String firstName; ...&#125; 위와 같이 firstName 필드를 선언했을 경우 first-name: lee first_name: lee firstName: lee firstname: lee 이와 같은 프로퍼티를 모두 바인딩한다.단 @configurationProperties의 prefix 인수은 스프링 2.0부터 소문자와 케밥 표기법만을 지원한다. 123name-test: first-name: lee ... name-test라는 프로퍼티명을 @configurationProperties로 바인딩 하는 경우 123456@Component@ConfigurationProperties(\"nametest\")public class Name &#123; private String firstName; ...&#125; nametest와 같은 소문자 형태와 케밥 표기법(‘name-test’)는 지원하지만 대문자(‘nameTest’)나 언더바(‘name_test’)를 사용하는 경우 아래와 같은 에러를 발생 시킨다. 1234567891011***************************APPLICATION FAILED TO START***************************Description:Configuration property name &apos;nameTest&apos; is not valid: Invalid characters: &apos;T&apos; Bean: name Reason: Canonical names should be kebab-case (&apos;-&apos; separated), lowercase alpha-numeric characters and must start with a letter","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING BOOT","slug":"PROGRAMMING/SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING-BOOT/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"SPRING BOOT","slug":"SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/tags/SPRING-BOOT/"}]},{"title":"스프링 부트 환경 설정과 우선순위","slug":"programming-springboot-study-002","date":"2019-04-12T12:07:27.000Z","updated":"2019-04-20T14:46:40.583Z","comments":true,"path":"2019/04/12/programming-springboot-study-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2019/04/12/programming-springboot-study-002/","excerpt":"","text":"스프링 부트의 환경 설정과 우선순위스프링 부트 가이드 문서에선 스프링 부트의 환경설정에 대해 이와 같이 설명하고 있다. Spring Boot lets you externalize your configuration so that you can work with the same application code in different environments. You can use properties files, YAML files, environment variables, and command-line arguments to externalize configuration. Property values can be injected directly into your beans by using the @Value annotation, accessed through Spring’s Environment abstraction, or be bound to structured objects through @ConfigurationProperties. 스프링 부트는 환경설정을 외부화 하므로써 같은 어플리케이션을 다른 환경에서도 사용할 수 있게한다. Properties 파일, YAML 파일, 환경변수 그리고 커맨트 라인 인수를 환경 설정을 외부화 한다. 설정 된 Property 값은 @Value 어노테이션을 통해 빈 객체에 직접 주입하며 스프링의 Environment 추상화를 통해 접근하거나 @ConfigurationProperties를 통해 객체를 구조화 할 수 있다. 스프링 부트는 알맞게 재정의 할 수 있도록 매우 독특한 PropertySource의 우선 순위를 이용한다. 홈 디렉토리에 위치한 Devtools 전역 프로퍼티 세팅 파일(devtools가 동작 중) @TestPropertySource 어노테이션(테스트) @SpringBootTest과 테스트 어노테이션을 이용한 어플리케이션의 일부분(?) 커맨트 라인 인수 Properties 파일 내 SPRING_APPLICATION_JSON(환경변수 혹은 시스템 프로퍼티에 내장 된 inline JSON) ServletConfig에 설정된 파라미터(web-dd 내 init-param) ServletContext에 설정된 파라미터(web-dd 내 init-param) java:comp/env의 JNDI 속성 JAVA 시스템 프로퍼티스(System.getProperties()) 운영체제 환경변수 random.* 형태만 가지는 RandomValuePropertySource 프로퍼티 jar 패키지 외부의 특정 프로파일 Properties(application-{profile}.propreties와 YAML) jar 패키지 내부의 특정 프로파일 Properties(application-{profile}.propreties와 YAML) jar 패지키 외부의 Properties(application.properties와 YAML) jar 패키지 내부의 Properties((application.properties와 YAML) @Configuration 클래스에 선언한 @PropertySource 어노테이션 기본 Properties (SpringApplication.setDefaultProperties로 정의) 이와 같이 Properties, YAML, 시스템 환경변수, 커맨드 라인 인수등을 이용하여 설정을 관리한다.주로 스프링이 XML 파일을 통해 관리한 반면 스프링 부트는 Properties 파일과 YAML 파일을 이용한다.초기 스프링부트는 Properties 파일만을 지원했지만 현재는 YAML을 지원 및 권장한다. 참고로 properties와 yaml 파일이 둘 다 존재하는 경우 yaml 파일을 우선 시 한다. YAML에 대한 설명은 별도 포스트 참고 설정 파일 위치의 우선순위SpringApplication은 해당 경로에 따라 application.properties 파일을 읽어들이며 이로부터 프로퍼티를 가져와 Spring Enviroment에 추가한다. 현 위치 하위 /config 디렉토리 현 위치 디렉토리 클래스패스 내 /config 패키지 루트 클래스패스 해당 우선순위를 기준으로 상위 경로는 하위 경로에 오버라이드 된다.Properties 파일은 YAML 파일로 대신할 수 있다. 파일명은 application.properties을 기본으로 spring.config.name 인수를 통해 변경할 수 있다.경로 또한 spring.config.location 인수를 이용하여 변경한다.디렉토리 혹은 파일이 여러 개인 경우 ,(쉼표)를 구분자로 명시한다. 어플리케이션 내 설정 파일의의 파일명 및 위치에 대한 설정은 파일이 로드 되기 전에 결정되어야 하는 부분이므로 커맨드 라인 인수, 운영체제 환경변수, 시스템 프로퍼티로 설정한다. 설정 인수가 1개인 경우1java -jar demo.jar --spring.config.name=demo 설정 인수가 2개 이상인 경우(쉼표 단위로 구분)1java -jar demo.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties 프로파일 프로퍼티스(Profile-specific Properties)application.properties와 더하여 프로파일 프로퍼티스는 application-{profile}.properties으로 네이밍 하는 것이 관행이다. 프로파일이 설정 되지 않은 경우 기본 프로파일(default) 가지고 있다. 만약 프로파일을 명시 하지 않은 경우 application-default.properties로 부터 읽어들인다. 프로파일 프로퍼티스 파일은 표준 application.properties와 같은 위치에서 읽어들인다. 프로퍼티 파일들은 언제나 jar 패키지 내부이든 외부이든 디폴트 프로퍼티보다 프로파일 프로퍼티를 오버라이딩하여 읽어들인다. 만약 프로파일이 여러 개일 경우, 최종 쟁취 전략(last-wins strategy)를 따른다. 예를 들어 spring.profiles.active 명시 된 프로파일은 SpringApplication API 이후에 추가되어진다. spring.config.location을 통해 파일을 추가한 경우, 프로파일 관련 관련 파일들은 대상이 되지 않는다. 프로파일 프로퍼티를 사용하고자 한다면 spring.config.location에 디렉토리를 명시해야한다. 임의 값을 설정하는 방법(Configuring Random Values)RandomValuePropertySource은 임의 값을 주입할 때 유용하다.(예를 들어 보안이나 테스트 관련하여)이러한 방법으로 integer, long, uuid 혹은 string 값을 만들 수 있다. 123456my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.uuid=$&#123;random.uuid&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125; random.int* 표현식은 OEPN value (, max) CLOSE이다.OPEN, CLOSE는 어떠한 문자든 될 수 있으며 value, max는 정수이다.만약 max를 포함한다면 value는 최소 값이 되고 max는 최대 값이 된다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING BOOT","slug":"PROGRAMMING/SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING-BOOT/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"SPRING BOOT","slug":"SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/tags/SPRING-BOOT/"}]},{"title":"스프링 부트 환경 설정과 YAML","slug":"programming-springboot-study-003","date":"2019-04-12T12:07:27.000Z","updated":"2019-04-20T14:45:20.165Z","comments":true,"path":"2019/04/12/programming-springboot-study-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2019/04/12/programming-springboot-study-003/","excerpt":"","text":"YAML(YAML Ain’t Markup Language)이란?YAML은 XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 ‘사람이 쉽게 읽을 수 있는’ 데이터 직렬화 양식이다. 2001년에 클라크 에반스가 고안했고, Ingy dot Net 및 Oren Ben-Kiki와 함께 디자인했다.YAML이라는 이름은 “YAML은 마크업 언어가 아니다 (YAML Ain’t Markup Language)” 라는 재귀적인 이름에서 유래되었다. 원래 YAML의 뜻은 “또 다른 마크업 언어 (Yet Another Markup Language)”였으나, YAML의 핵심은 문서 마크업이 아닌 데이터 중심에 있다는 것을 보여주기 위해 이름을 바꾸었다. 오늘날 XML과 JSON이 데이터 직렬화에 주로 쓰이기 시작하면서, 많은 사람들이 YAML을 ‘가벼운 마크업 언어’로 사용하려 하고 있다.[출처 : https://ko.wikipedia.org/wiki/YAML] YAML은 공백 문자를 이용하여 키를 구분하며 한 파일을 하이픈 3개(—) 단위로 나누어 사용할 수 있다. YAML 파일을 로드하기 위해선 snakeyaml 라이브러리가 프로젝트 내에 포함 되어야 한다.스프링 부트에서 기본적으로 해당 기능이 제공되는 것은 스프링 부트 스타터의 영향이다.spring-boot-starter의 dependency를 확인해보면 금방 알 수 있다. 위와 같이 snakeyaml 라이브러리를 포함하고 있는 것을 확인할 수 있다. 스프링 부트는 YAML을 이용하기 위해 2가지의 Class를 제공한다.YamlPropertiesFactoryBean를 통해 YAML을 Properties로 읽어오며 YamlMapFactoryBean를 통해 YAML을 MAP형태로 제공한다. 앞서 설명했듯이 YAML은 하이픈 3개(—)를 이용하여 파일을 나눌 수 있다.이를 이용하여 프로파일에 따라 구분하여 설정할 수 있다.스프링이 프로파일별로 파일을 분리하는 반면 스프링부트는 한 파일 내에 프로파일을 구분할 수 있다. 123456789101112server: address: 192.168.1.100---spring: profiles: developmentserver: address: 127.0.0.1---spring: profiles: production &amp; eu-centralserver: address: 192.168.1.120 위와 같은 방식으로 spring.profiles을 구분할 수 있으며 연산자를 이용하는 방법도 있으니 참고하면 좋다. !: NOT 연산자, 해당 프로파일을 제외한다. &amp;: AND 연산자, 해당 프로파일과 다른 프로파일을 포함한다. |: OR 연산자, 해당 파일 혹은 다른 파일을 포함한다. 또 다른 방법으로 application-[profile].yml과 같이 프로파일을 파일명에 추가하여 구분할 수 있다.서비스 실행 시 프로파일 값을 -Dconfig 값으로 전달하여 설정 파일을 구분 처리할 수 있다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING BOOT","slug":"PROGRAMMING/SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING-BOOT/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"SPRING BOOT","slug":"SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/tags/SPRING-BOOT/"}]},{"title":"스프링 부트(Spring Boot)란?","slug":"programming-springboot-study-001","date":"2019-03-30T07:33:58.000Z","updated":"2019-04-09T14:31:06.579Z","comments":true,"path":"2019/03/30/programming-springboot-study-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2019/03/30/programming-springboot-study-001/","excerpt":"","text":"1. 스프링 부트는 무엇일까?자바 개발자라면 스프링 프레임워크에 대해서 한번은 들어봤거나 현재도 사용하고 있을 것이다.스프링은 경량, 안정성 그리고 DI, AOP 많은 장점을 바탕으로 국내 표준으로 통하는 프레임워크이다. 이러한 장점이 있는 반면 환경 설정을 위한 많은 시간이 소비되는 단점이 존재했다.당장 프로젝트에 필요한 Dependency와 MVC 구조, 애플리케이션 배포를 위한 서버(웹서버 + WAS) 등등 이러한 단점을 보완해줄 수 있는 것이 바로 스프링 부트이다. 스프링 부트 프로젝트 홈페이지에선 스프링 부트에 대해 이렇게 설명하고 있다. 스프링 부트는 단독으로 실행이 가능하며 상용 수준의 스프링 기반 어플리케이션을 간단히 만들 수 있다.아주 적은 설정을 통해 스프링 플랫폼과 서드파티 라이브러리를 사용할 수 있게 만들어 준다. 특징 단독 실행 가능한 스프링 어플리케이션을 만든다. 임베디드 톰캣, 제티 혹은 언더토우를 내장하고 있다.(WAR 파일을 배포할 필요 없다) 기본 제공 되는 ‘스타터’ 의존성을 통해 빌드를 간단히 설정할 수 있다. 자동화 된 스프링 설정과 서드 파티 라이브러리를 사용할 수 있다. 상용화에 필요한 통계 및 상태 점검 그리고 외부 설정을 제공한다. 설정을 위한 XML과 코드를 작성할 필요가 없다. 스프링은 이와 같이 스프링이라는 프레임워크의 설정 및 사용법을 간소화 한 툴이다.개발자에게 있어 비즈니스 로직 구현에 집중할 수 있는 환경을 만들어 주는 것이다. 참고로 궁금한 점이 있다면 stackoverflow를 모니터링 하고 있으니 spring-boot 태그를 남겨달란다. 2. 스프링 부트의 시작단계Spring Boot Reference Guide를 참고하여 스프링 부트 튜토리얼을 시작해보고자 한다.해당 포스트 작성 당시 최신 버전은 Spring Boot 2.1.3.RELEASE 이다. 시스템 요구환경 JAVA JAVA 8 이상(JAVA 11 포함) Spring Spring Framework 5.1.5.RELEASE 이상 Build ToolMaven 3.3 + Gradle 4.4 + Servlet ContainersTomcat 9.0 Jetty 9.4 Undertow 2.0 스프링 부트를 위한 시스템 요구환경을 맞춘 후 STS(Spring Tool Suite) 혹은 이클립스 + 스프링 플러그인을 설치한다. New &gt; Spring Starter Project를 클릭하여 프로젝트를 생성한다. Spring Starter Project의 Dependencies를 추가해준다.Dependencies를 추가할 경우 아래와 같이 build.gradle 파일에 추가된다. 아래와 같이 프로젝트에 Dependencies가 추가된 것을 확인할 수 있다. 3. 스프링 부트 스타터이와 같이 스프링 부트는 개발자가 일일이 의존 관계 및 라이브러리를 추가하는 번거러움을 줄이기 위해 스프링 부트 스타터를 제공한다. 프로젝트에 필요한 스프링 부트 스타터를 추가만 해주면 일일이 어떤 라이브러리가 필요한지 찾아볼 필요가 없어진다. 스프링 부트 스타터 선언 방법은 다음과 같다. ‘org.springframework.boot:spring-boot-starter-[스타터명]‘ 스타터의 종류나 스타터 내 의존 관계를 Spring Boot Reference Guide - Starters에서 할 수 있다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING BOOT","slug":"PROGRAMMING/SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING-BOOT/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"SPRING BOOT","slug":"SPRING-BOOT","permalink":"https://lee-jung-hoon.github.io/tags/SPRING-BOOT/"}]},{"title":"Spring MVC란 무엇인가? - 구조 및 설정","slug":"programming-spring-study-011","date":"2018-11-20T15:34:57.000Z","updated":"2018-11-21T15:49:17.187Z","comments":true,"path":"2018/11/21/programming-spring-study-011/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/21/programming-spring-study-011/","excerpt":"","text":"1. Spring MVC의 기본 구조앞에서 살펴 봤듯 스프링은 MVC와 Front Controller 디자인 패턴을 따른다.본격적으로 Spring MVC 구조에 대해 알아보고자 한다. 기본적인 구조는 번호 순서대로 읽어보면 파악할 수 있다. 클라이언트(브라우저)가 URL을 요청하면 DispatcherServlet이 가장 먼저 해당 요청을 낚아챈다. DispatcherServlet은 HandlerMapping에게 URL에 적합한 컨트롤러를 요청하며 이를 찾았다면 다시 HandlerAdapter에게 메소드를 요청한다. 결과적으로 적합한 Controller의 메소드는 처리 결과와 View 이름을 DispatcherServlet에 반환한다. 다시 DispatcherServlet은 ViewResolver에게 적합한 View를 찾도록 요청하며 최종적으로 View와 처리결과(Model and View)를 클라이언트에게 반환한다. 2. Dispatcher Servlet 중앙에 위치하여 모든 연결을 중계 및 담당한다. 중앙에 위치한 배치관리자로써 클라이언트로부터 URL 요청을 가장 먼저 받는다. HandlerMapping에게 클라이언트가 요청한 URL과 맞는 컨트롤러를 검색 요청한다. ViewResolver로부터 리턴 받은 View와 처리 결과를 클라이언트에게 돌려준다. Dispatcher Servlet 설정 방법DispatchServer을 설정하는 방법은 web.xml 해당 내용을 추가합니다.url-pattern 설정을 통해 다음과 같은 요청이 들어올 경우 동작하도록 합니다.contextConfigLocation을 통해 서블릿 설정 파일 목록을 초기화 해줍니다.만약 설정하지 않을 경우 [servlet-name-servlet.xml]을 읽습니다.서블릿 설정 파일에는 HandlerMapping, ViewResolver 등에 대한 빈을 설정합니다. 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 3. HandlerMapping 클라이언트의 요청에 따라 적합한 Controller를 결정한다. order 속성을 통해 다수의 HandlerMapping와 적용 순서를 설정할 수 있다. 별도의 HandlerMapping을 설정하지 않으면 DefaultAnnotationHandlerMapping이 설정된다. HandlerMapping의 종류1. DefaultAnnotationHandlerMapping 흔히 사용하는 어노테이션을 이용한 HandlerMapping @RequestMapping 어노테이션을 통해 매핑 Key를 설정한다. 2. SimpleUrlHandlerMapping 매핑 Key와 Bean Name을 직접 매핑한다. Bean을 등록한 후 mappings에 별도로 설정한다. 123456789&lt;bean id=\"handler\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/hello.do\"&gt;hello&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"hello\" class=\"com.devjh.mvc.HelloController\" /&gt; 3. BeanNameUrlHandlerMapping 매핑 Key와 Bean을 함께 지정한다. 123&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt;&lt;bean name=\"/hello.do\" class=\"com.devjh.mvc.HelloController\"/&gt; ViewResolver View 객체를 생성하고 결과 화면으로 보여주도록 반환한다. ViewResolver를 통해 Controller 내에서 View 객체를 생성하지 않고 이름만을 리턴한다. 이를 통해 Controller와 View의 역할이 분리될 수 있다. 대표적인 ViewResolver인 InternalResourceViewResolver의 설정 방법 위와 같이 prefix와 suffix를 설정하면 ‘/WEB-INF/views/[view 이름].jsp’의 뷰 객체를 반환한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"MVC","slug":"MVC","permalink":"https://lee-jung-hoon.github.io/tags/MVC/"}]},{"title":"Spring MVC란 무엇인가? - 디자인 패턴","slug":"programming-spring-study-010","date":"2018-11-20T14:26:22.000Z","updated":"2018-11-20T15:49:54.829Z","comments":true,"path":"2018/11/20/programming-spring-study-010/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/20/programming-spring-study-010/","excerpt":"","text":"스프링 MVC가 가지는 디자인 패턴MVC는 Model-View-Controller의 약자로 소프트웨어 디자인 패턴의 한 종류입니다. MVC 아키텍쳐 패턴을 스프링만의 것이라 생각하시는 경우가 많습니다.하지만 MVC 패턴은 스프링 뿐만 아니라 ASP부터 javascript, Redux를 이용한 React와 같이 다양한 언어와 라이브러리에서 사용되는 아키텍쳐 패턴입니다. MVC 패턴은 사용자의 요청을 받아 뷰잉 로직과 비즈니스 로직을 분리하는 디자인패턴 모델(Model)MVC 디자인 패턴에서 정보를 담아두는 역할을 담당한다.Bean 객체에 해당하며 DB 서버로부터 불러들인 데이터를 담아 View에게 전달한다. 뷰(View)클라이언트에게 보여지는 화면단을 의미한다.사용자가 입력한 데이터를 컨트롤러에게 전달하거나 처리 결과를 컨트롤러로부터 전달받는다. 컨트롤러(Controller)클라이언트로부터 입력받은 데이터를 이용하여 비즈니스 로직을 수행한다.비즈니스 로직의 처리 결과를 뷰에게 전달한다. 이 외에 MVP(Model-View-Presenter), MVVM(Model-View-ViewModel) 다양한 디자인 패턴이 존재한다.(해당 내용은 별도 포스트 예정) 스프링은 MVC 패턴과 함께 Front Controller 패턴을 따른다.Front Controller 패턴은 클라이언트의 요청을 받은 배치 관리자(Dispatcher)가 적합한 Controller를 실행 시키는 구조를 가진다. 스프링 MVC에서는 Dispatcher Servlet이 이러한 역할을 담당한다. 출처https://en.wikipedia.org/wiki/Model–view–controllerhttps://en.wikipedia.org/wiki/Front_controller","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"MVC","slug":"MVC","permalink":"https://lee-jung-hoon.github.io/tags/MVC/"}]},{"title":"30분 만에 간단한 카카오톡 챗봇(?) 만들기 - 1편","slug":"kakaochatbot-001","date":"2018-11-10T07:36:46.000Z","updated":"2018-11-11T07:59:48.798Z","comments":true,"path":"2018/11/10/kakaochatbot-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/10/kakaochatbot-001/","excerpt":"","text":"앞으로 2편에 나눠 카카오톡 플러스 친구를 이용한 간단한 챗봇(?)을 만드려보려 합니다.사실 이정도 수준이 챗봇이라 부르긴 힘든게 사실입니다. 단순한 자동응답 카카오 계정을 만든다고 생각하시면 좋을 듯 합니다. 간단하지만 개발자가 아니라면 몇 가지 배경지식이 필요합니다. 필요한 것들 Node.js (서버의 역할을 하며 카카오톡, 각종 API와 연동을 담당합니다.) javascript, jQuery 카카오 계정(플랫폼을 카카오톡 플러스친구로 사용하므로) 실제 서비스가 아닌 간단한 보여주기이므로 DB나 nginx와 같은 부분은 적용되지 않습니다. 1. 카카오 API 등록먼저 카카오 플러스친구 관리센터에 접속하여 플러스친구를 등록합니다.등록 내용은 개발과 크게 관련이 없으므로 마음대로 입력하셔도 됩니다. 모두 등록 하신 후 스마트채팅 메뉴로 이동하여 추가 개발을 통해 질문에 답변하는 API형을 선택합니다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"CHATBOT","slug":"PROGRAMMING/CHATBOT","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/CHATBOT/"}],"tags":[{"name":"챗봇","slug":"챗봇","permalink":"https://lee-jung-hoon.github.io/tags/챗봇/"}]},{"title":"AOP란 무엇일까? - 02","slug":"programming-spring-study-009","date":"2018-11-09T12:34:34.000Z","updated":"2018-11-10T20:11:05.951Z","comments":true,"path":"2018/11/09/programming-spring-study-009/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/09/programming-spring-study-009/","excerpt":"","text":"AOP의 핵심 용어 정리 Target(타겟) : 공통 기능이 부여될 대상을 의미합니다. 클래스 혹은 메소드가 될 수 있습니다. Aspect(애스팩트) : 여러 객체에 적용될 공통 기능을 의미합니다. ex) 보안, 로그, DB처리 Advice(어드바이스)\u001d : 공통 기능이 부여될 시점을 의미합니다. ex) 메소드 호출 전, 메소드 실행 이후 JoinPoint(조인포인트) : Advice가 적용 될 수 있는 지점을 의미하며 스프링의 경우 프록시 방식의 메소드 조인포인트를 지원합니다. 다른 AOP 방식의 경우 필드에도 적용이 가능하다. PointCut(포인트컷) : 여러 개의 조인 포인트를 모아 포인트컷이라 부릅니다. AOP Advice의 종류 &lt;aop:before&gt; : 메소드가 실행되기 전에 실행 &lt;aop:after-returning&gt; : 메소드가 정상 실행 된 후 실행 &lt;aop:after-throwing&gt; : 메소드 실행 중 Exception 발생 시 실행 &lt;aop:after&gt; : 메소드 실행 중 Exception이 발생하여도 실행 &lt;aop:around&gt; : 메소드 실행 전 1회, 실행 후 1회 및 Exception 발생 시 실행 스프링 AOP에서는 주로 around advice나 before를 사용한다. 스프링에 AOP 구현하기앞서 살펴본 바와 같이 스프링은 프록시를 이용한 AOP를 제공한다.이 방법에는 POJO 클래스를 이용한 XML 적용과 어노테이션(@Aspect)으로 두 가지가 있다. POJO(Plain Old Java Object) : 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 “무거운” 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다. (출처 : 위키피디\u001c아) 1. XML을 이용한 스프링 AOPXML을 이용한 스프링 AOP를 사용할 경우, Aspect를 어디에 언제 적용할지를 설정한다.이때 Aspect 클래스는 POJO(순수 자바 객체)이다. 적용을 위한 작업 순서 Dependency 설정 pom.xml에 의존 라이브러리(aspectj) 추가 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;/dependency&gt; 공통 코드(Proxy Code) 작성 Aspect 코드 구현 1234567891011public Object toLog(ProceedingJoinPoint joinpoint) throws Throwable &#123; String methodName = joinpoint.getSignature().getName(); // 메소드명 long startTime = System.nanoTime(); // 시작시간 try &#123; Object obj = joinpoint.proceed(); // 핵심 기능 실행 return obj; &#125; finally &#123; long endTime = System.nanoTime(); // 종료시간 System.out.println(\"[\" + methodName + \"] is \" + (endTime - startTime)); &#125;&#125; Aspect 코드 구현 시, 스프링 AOP에서 가장 많이 사용되는 Advice인 Around Advice로 구현할 경우 ProceedingJoinPoint의 proceed()를 통해 핵심 기능을 실행시킨다. config.xml 설정AOP 설정 파일에 Aspect 빈 등록 및 PointCut 설정 123456789&lt;!-- 공통 기능을 제공할 클래스를 빈에 등록처리 --&gt;&lt;bean id=\"logAct\" class=\"com.jhdev.asfect.LogAspect\" /&gt;&lt;!-- Aspect 설정: Advice를 어떤 Pointcut에 적용할 지 설정 --&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"logAct\"&gt; &lt;aop:around pointcut=\"execution(* com.jhdev.board.service..*Impl.*(..))\" method=\"toLog\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2. 어노테이션을 이용한 스프링 AOP어노테이션을 이용한 AOP 설정은 XML을 이용한 방법과 유사하지만 비교적 더 간단하다.공통 기능 클래스에 어노테이션과 함께 PointCut을 설정한다. 어노테이션을 이용하는 방법을 추천한다. 간결하고 생산성이 빠를 수 있다. 적용을 위한 작업 순서 Dependency 설정 pom.xml에 의존 라이브러리(aspectj) 추가 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.2&lt;/version&gt;&lt;/dependency&gt; 공통 코드(Proxy Code) 작성 Aspect 코드 구현 1234567891011121314151617181920212223242526@Aspect // Aspect Anotationpublic class LogAspect &#123; // pointcut 설정 @Pointcut(\"within(com.jhdev.board.service.*)\") private void pointcutMethod() &#123; &#125; // pointcut 메소드 설정 @Around(\"pointcutMethod()\") public Object toLog(ProceedingJoinPoint joinpoint) throws Throwable &#123; String methodName = joinpoint.getSignature().getName(); // 메소드명 long startTime = System.nanoTime(); // 시작시간 try &#123; Object obj = joinpoint.proceed(); // 핵심 기능 실행 return obj; &#125; finally &#123; long endTime = System.nanoTime(); // 종료시간 System.out.println(\"[\" + methodName + \"] is \" + (endTime - startTime)); &#125; &#125; // pointcut 직접 설정 @Before(\"execution(public * com.jhdev.board.service..*(..))\") public void beforeTest() &#123; System.out.println(\"Before Advice\"); &#125; Aspect 코드 구현 시, XML POJO 방식과 대부분 동일하지만 다른 점은 pointcut과 advice 설정을 Aspect 구현 클래스에서 한다. config.xml 설정AOP를 xml에 설정하던 것과 다르게 빈과 autoproxy만을 설정 12345&lt;!-- 공통 기능을 제공할 클래스를 빈에 등록처리 --&gt;&lt;bean id=\"logAct\" class=\"com.jhdev.asfect.LogAspect\" /&gt;&lt;!-- AutoProxy 설정--&gt;&lt;aop:aspectj-autoproxy /&gt; AspectJ의 PointCut 표현 방식AspectJ 사용 시 PointCut을 명시하는 방법에 대해 알아보자이를 AspectJ 문법이라고 부른다.AOP는 다양한 핵심 기능에 공통 기능을 적용해야하기 때문에 AspectJ 문법으로 범위를 만들어야 한다. 기본 문법* : 모든 클래스 혹은 메소드. : 현재 패키지.. : 0개 이상 AspectJ PointCut 명시자execution : [접근명시자패턴] 리턴타입패턴 이름패턴(파라미터패턴) 형태로 세밀한 명시가 가능within : 특정 메소드가 아닌 특정 패키지 하위에 모든 메소드을 명시하는 경우 Executionexecution([접근명시자패턴] 리턴타입패턴 이름패턴(파라미터패턴)) execution(publid void set*(..))리턴 타입이 void이면서 메소드명이 set으로 시작하는 경우 execution(* com.jhdev.board.service.*.*())해당 패키지 내 클래스 중 파라미터가 없는 메소드 execution(* com.jhdev.board.service..*.*())해당 패키지와 해당 패키지 하위에 존재하는 패키지 내 파라미터가 없는 메소드 WithInwithin(com.jhdev.board.service.*())해당 패키지 내 모든 클래스의 메소드 within(com.jhdev.board.service..*())해당 패키지와 해당 패키지 하위에 존재하는 패키지 내 모든 클래스의 메소드","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"AOP","slug":"AOP","permalink":"https://lee-jung-hoon.github.io/tags/AOP/"}]},{"title":"도커(Docker) 기본 사용법 및 몽고 DB 설치","slug":"docker-003","date":"2018-11-07T02:17:48.000Z","updated":"2018-11-09T05:33:56.550Z","comments":true,"path":"2018/11/07/docker-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/07/docker-003/","excerpt":"","text":"앞선 포스트를 통해 도커가 무엇이며 어떻게 설치하는지에 대해 알아봤습니다.이번엔 도커의 가장 기본적인 사용법에 대해 알아보도록 하겠습니다. 본격적으로 도커의 사용법 배우기 전에 핵심 개념 중 하나인 이미지(Image)에 대해 알아보고 가겠습니다. 도커에서 이미지(Image)란?도커 이전에 VirtualBox나 VMWare와 같은 가상 머신 툴을 사용해 보신 분들이라면 이미지라는 개념에 대해 익숙 하실겁니다.가상 머신 툴의 경우 하이퍼바이저를 통해 부팅 되는 게스트 운영체제 자체를 이미지 파일로 특정 경로에 저장하고 있으며 이를 배포하기도 합니다.해당 이미지 파일을 임포트하여 사용할 경우 동일한 환경을 구성할 수 있죠. 도커에서도 이와 유사한 개념입니다. 단지 다른 점이라면 가상 머신 툴의 이미지가 게스트 운영체제 자체라면 도커의 이미지는 필요한 라이브러리만으로 구성되어있다는 점입니다.그리고 도커는 이미지를 실행하는 것이 아닌 이미지를 기반으로 컨테이너를 만들어 실행한다는 점이 다릅니다. 그리고 도커는 이러한 이미지들을 공유하기 위한 도커 허브라는 웹 호스팅 서비스를 제공합니다.깃과 깃허브의 관계와 비슷하다고 볼 수 있습니다.다른 점이라면 깃은 리누스 토발즈가 만들고 깃허브는 깃허브 팀이 만들었지만 도커와 도커 허브는 모두 도커 팀에서 만들었다는 점입니다. 이번 포슽트에선 몽고 DB를 설치하며 기본적인 도커 사용법을 알아보고자 합니다. 1. 도커 허브에서 몽고 DB 이미지 검색제일 먼저 도커 허브에서 필요한 이미지를 검색합니다.mongo를 검색한 결과 도커 허브에서 제공하는 몽고DB 정식 이미지가 출력됩니다.도커 허브를 통하는 방법 외에도 docker search [이미지 이름]:[태그]를 통해 검색 할 수 있습니다. 2. 몽고 DB 이미지 내려 받기도커 허브를 통해 알게 된 docker pull [이미지 이름] 명령어를 입력합니다.몽고 DB 도커 이미지를 내려받는 명령어입니다.태그를 입력하지 않을 경우 latest로 설정되며 최신 버전을 내려받습니다. 3. 내려받은 도커 이미지 목록 확인이미지가 내려받아졌다면 docker images [이미지 이름] 명령어를 입력하여 이미지 목록을 확인합니다.이미지 이름을 입력하지 않을 경우 모든 이미지 목록이 출력됩니다. 4. 컨테이너 실행 및 프로세스 확인이미지를 이용하여 컨테이너를 생성하고 실행합니다.docker run --name [프로세스명] -p [포트포워딩] -d [이미지명]\u001d 명령어 입력 시 이미지를 컨테이너로 만들고 해당 컨테이너를 실행합니다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"}]},{"title":"Mac(맥 OS)에 도커 설치하기","slug":"docker-002","date":"2018-11-06T08:35:35.000Z","updated":"2018-11-07T05:29:15.258Z","comments":true,"path":"2018/11/06/docker-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/docker-002/","excerpt":"","text":"앞서 도커란 무엇인가에 대해 살펴 보았습니다. 이번엔 도커를 설치해보고자 합니다. 현재 PC가 Mac(맥 OS)이므로 해당 환경에 맞춰 진행하도록 하겠습니다.Windows 환경에서의 설치 또한 추후 업로드 할 예정입니다. 1. 도커 홈페이지 접속 도커 공식 홈페이지에 접속하여 [Get Started]를 선택하시면 운영체제별 설치 페이지가 나타납니다. 과거엔 CentOS나 Ubuntu 등의 리눅스 운영체제에 apt-get, yum과 같은 패키지 다운로더를 통해서만 설치가 가능했는데현재는 다양한 운영체제로 확장되었습니다.(물론 Windows의 경우 가상머신 툴 등이 포함되어 다소 차이가 있습니다. 추후 업로드 예정) 2. 도커 설치 파일 다운로드 및 설치 진행도커 홈페이지에서 Docker for Mac(도커 디스크 이미지)를 다운 받아 그대로 설치를 진행합니다.별다른 어려운 부분은 없습니다.GUI이기 때문에 단순 클릭 몇 번이면 설치가 완료됩니다. 3. 설치 확인마지막으로 터미널에 접속하여 docker --version을 입력하여 설치된 도커의 버전을 확인합니다.해당 명령어를 입력 했을 때, 버전이 출력된다면 일단 도커 엔진이 설치된 상태입니다. 다음 포스트에서는 도커의 기본적인 명령어와 사용법에 대해 알아보겠습니다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"},{"name":"설치","slug":"설치","permalink":"https://lee-jung-hoon.github.io/tags/설치/"}]},{"title":"도커(Docker)란?","slug":"docker-001","date":"2018-11-06T08:35:34.000Z","updated":"2018-11-07T05:29:48.895Z","comments":true,"path":"2018/11/06/docker-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/docker-001/","excerpt":"","text":"도커는 사실 새로운 개념의 기술은 아니다. 도커 이전에 리눅스 컨테이너(LXC)라는 기술이 존재했다. 리눅스 컨테이너는 리눅스 커널에 포함되어 있었던 기술로 cgroups와 namespace를 활용하여 cpu, 메모리, 디스크, 네트워크 등을 할당하고 프로세스, Users 등을 분리할 수 있었다. 하지만 리눅스 컨테이너는 프로세스 단위로 분리한 것 외엔 실제 운영 시 활용할 수준에 이르지 못했다. 그래서 등장한게 바로 도커(Docker)이다.일단 도커를 알기 전에 우리는 가상머신(VM)에 대해 먼저 알고 갈 필요가 있다. 가상머신(Virtual Machine)란?컴퓨터 안에 존재하는 또 다른 컴퓨터, 하나의 호스트에 다수의 운영체제를 생성하는 방식이다.각 운영체제 하나 하나를 가상 머신이라는 단위로 부른다. 대표적으로 VirtualBox, VMWare, Hyper-V, Parallels 등이 존재한다. 위 이미지는 가상머신과 도커의 기본적인 구조로 차이점을 쉽게 알 수 있을 것이다. 가상 머신은 호스트 운영체제 내 하이퍼바이저(가상화 기술)로 게스트 운영체제를 설치하는 구조이다.결국 게스트 운영체제 자체를 설치하기 때문에 의존 라이브러리와 커널등은 따라올 수 밖에 없게 된다.그러다보면 호스트의 많은 리소스를 할당 및 차지 하게 된다. 이에 반해 도커는 게스트 운영체제를 생성하는 것이 아닌 가상화 된 공간을 프로세스 단위로 생성한다.가상 머신과 다르게 호스트와 커널을 공유하고 컨테이너에 필요한 라이브러리만 설치하게 되는 것이다.필요한 부분만 묶어 이미지라는 단위로 배포하고 실행하므로 가상 머신에 비해 적은 리소스를 차지한다. LXC(LinuX Container, 리눅스 컨테이너)앞서 설명한 리눅스 컨테이\u001c너와 도커의 관계에 대해 궁금할 수 있다.초창기 도커의 경우 리눅스 커널 단에 포함되어 있던 리눅스 컨테이너를 활용하였다. 현재는 LibContainer 개발 프로젝트를 진행하였고 리눅스 컨테이너로부터 자유로워진 상태이다.리눅스 컨테이너가 커널단이라면 립컨테이너는 유저랜드(Userland) 라이브러리이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"}]},{"title":"AOP란 무엇일까? - 01","slug":"programming-spring-study-008","date":"2018-11-05T15:50:51.000Z","updated":"2018-11-10T13:13:03.267Z","comments":true,"path":"2018/11/06/programming-spring-study-008/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/programming-spring-study-008/","excerpt":"","text":"AOP란 무엇일까?AOP는 Aspect Oriented Programming의 약자로 ‘관점 지향 프로그래밍’OOP는 Object Oriented Programming인 것이 생각날 것이다.객체 지향과 관점 지향이라는 차이점이 존재하지만 이것이 반대 개념을 의미하는 것은 아니다. 객체 지향 프로그래밍에서 공통된 기능을 모든 모듈에 적용해야할 경우 상속과 같은 방법을 사용할 수 있지만 자바는 다중 상속이 불가능하다는 점과 공통 기능, 핵심 기능이 마구자비로 뒤섞여 비효율적인 소스가 될 수 있다. AOP는 이러한 문제점을 해결 할 수 있다. 핵심 기능과 공통 기능을 분리 시키고 필요할 때만 사용할 수 있게 하는 것이다. 결국 OOP 구조를 돕는 보조적인 역할을 하는 셈이다. 실제 업무 중 AOP로 활용한다면 시간과 자원을 절약할 수 있는 경우가 많다. 업무 중 있었던 에피소드를 하나 소개해볼까 한다. 위는 간단하 예시이지만 ASIS -&gt; TOBE로의 데이터 이행 작업을 해야했다. 123456789/** * 게시글 이행 Class */public class TrnsBoard implements TrnsBase &#123; @Override public void startContent() &#123; ... &#125;&#125; 123456789/** * 방문자 기록 이행 Class */public class TrnsVisit implements TrnsBase &#123; @Override public void startContent() &#123; ... &#125;&#125; 이와 같은 게시글, 방문자 기록 이행 클래스가 존재한다고 가정해보자.이때 실제 이행 이전에 예상 시간 및 정확한 이행을 위해 시간 측정은 필수이다.(이행 테스트 시나리오에서의 측정 시간과 차이가 난다면 무언가 문제가 있음을 알 수 있다.) 하지만 해당 코드는 큰 문제점을 가지고 있다.그것은 바로 중복되는 소스로 인해 유연한 로직을 구현할 수 없다는 점이다. 만약 시간 측정 방식을 바꾸거나 해당 로그 표기 방법을 바꿔야한다면 프로젝트 내 해당 소스가 반영된 모든 메소드를 수정해야한다. 바로 관심사의 분리에 실패한 코드인 것이다. 이러한 구조를 조금 개선해볼 수 있을 것이다. 123456789101112131415161718192021/** * 프록시 객체 */public class TrnsProxy implements TrnsBase &#123; private TrnsBase target; /** * 생성자 초기화 클래스 */ public TrnsProxy(TrnsBase target) &#123; this.target = target; &#125; @Override public startContent() &#123; long sTime = System.currentTimeMillis(); // 실행 전 시간 측정 target.startContent(); // 이행(핵심 기능 수행) long eTime = System.currentTimeMillis(); // 실행 후 시간 측정 System.out.println(\"수행 시간 : \" + (eTime - sTime)); // 실행 시간 측정 &#125;&#125; 또 다른 클래스를 생성하여 게시글, 방문자 이행와 같이 ‘TrnsBase’라는 인터페이스를 상속받아 구현한다.다른 점이라면 생성자를 통해 또 다른 구현 클래스를 전달 받고 실행시간을 출력하는 동작과 핵심 로직을 동시에 수행한다는 점이다. 이로써 핵심 기능은 다른 객체에서 수행하고 공통 기능만을 제공하게 되었다. 실행 전 시간 측정 핵심 기능 수행 실행 후 시간 측정, 실행 시간 출력 이러한 실행 구조를 가지게 된다.클라이언트와 타겟 사이에 대행을 끼워 넣는 것이다.이러한 객체를 프록시 객체라 부르며 AOP의 핵심인 공통 기능과 핵심 기능을 분리할 수 있다. 이렇게 핵심 기능과 공통 기능을 분리하여 삽입하는 방법은 크게 3가지가 존재한다. 컴파일 전에 별도 컴파일러를 통해 핵심 기능 사이에 공통 기능을 삽입하여 최종 바이너리를 만드는 방식(AspectJ) 클래스 로딩 시, 별도의 에이전트를 이용하여 JVM이 클래스를 로딩하는 시점에 해당 클래스의 바이너리를 수정하여 삽입하는 방식(AspctWerkz) 런타임 시, 프록시 객체를 생성하여 핵심 로직을 구현한 객체에 접근하는 방식(Spring AOP) 각 방법별로 장단점이 존재하겠지만 간단히 살펴본다면 컴파일 시 타겟 파일을 수정하거나 클래스 로딩 시 바이너리를 가로채 조작하는 방법은 프록시 객체를 별도로 생성할 필요가 없으며 적용할 수 있는 시점이 다양하므로 자유롭다는 장점을 가지고 있다.(프록시 방식은 객체가 생성된 이후)하지만 바이너리 코드를 변경하기 위해선 클래스를 로드하는 JVM에 옵션 설정이 필요하며 별도의 에이전트가 필요하다는 단점이 존재한다. 스프링에서는 프록시를 이용한 AOP방식을 지원한다. 대부분의 기능은 프록시 방식으로 충분히 구현이 가능하며 이보다 더 깊은 기능을 필요로 할때 바이너리를 조작하는 방법을 사용하는 것이 좋다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"AOP","slug":"AOP","permalink":"https://lee-jung-hoon.github.io/tags/AOP/"}]},{"title":"스프링 자바를 이용한 주입 설정","slug":"programming-spring-study-007","date":"2018-10-20T12:01:23.000Z","updated":"2018-10-24T03:55:18.538Z","comments":true,"path":"2018/10/20/programming-spring-study-007/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/20/programming-spring-study-007/","excerpt":"","text":"1.자바를 이용한 설정그동안 XML을 이용한 의존 자동 주입을 살펴봤다.스프링은 이 외에도 자바를 이용한 주입 설정을 지원한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"스프링 DI(의존주입)-4","slug":"programming-spring-study-006","date":"2018-10-04T14:01:23.000Z","updated":"2018-10-08T14:59:40.000Z","comments":true,"path":"2018/10/04/programming-spring-study-006/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/04/programming-spring-study-006/","excerpt":"","text":"1.의존 자동 주입-2바로 앞 포스트에서 Autowired 어노테이션을 이용한 의존 객체 자동 주입을 알게 되었다.스프링은 Autowired 외에도 Resource 어노테이션을 이용한 자동 주입을 지원한다. Autowired가 타입을 이용하는 반면 Resource는 빈의 이름을 이용한다는 차이점이 있다. Autowired와 사용 방법에서 많은 차이는 없다. 설정 XML 내에 &lt;context:annotation-config/&gt; 추가 의존 주입 대상에 @Resource 어노테이션 작성 하지만 큰 차이점이 존재하는데Autowired와 다르게 생성자에는 적용할 수 없다는 점이다.그 외에 필드나 설정 메소드에는 동일하게 적용할 수 있다. 필드 자동 주입 123456789public calss MemberRegisterService &#123; @Resource(name=\"memberDao\") private MemberDao memberDao; // 의존 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; ...&#125; 설정 메소드 자동 주입 123456789public calss MemberPrinter &#123; private MemberPrinter printer; @Resource(name=\"memberPrint\") public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; 위와 같이 필드와 설정 메소드에 설정할 수 있다. Autowired와 동일하게 의존 객체를 자동 주입할 경우 constructor-arg나 property 태그를 사용하지 않아도 된다. 12345&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.MemberDao\"&gt;&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 설정 XML에 Bean을 등록하고 id 속성을 Resource 어노테이션의 name 속성과 매핑해준다. 2. Resource의 기본적인 특성Resource는 Autowired와 다르게 빈의 이름을 기준으로 주입한다고 설명했다.만약 Resource 어노테이션의 name 속성을 설정하지 않는다면 어떻게 될까? 답은 Autowired와 같이 동일한 유형을 찾아 주입한다.Autowired와 동작 순서가 반대인 셈이다.Resource 또한 name 속성이 없고 동일 유형의 빈이 다수 존재한다면 Exception이 발생한다. 3. Resource의 동작 순서Autowired와 반대 순서로 동작하는 Resource 동작 순서를 정리한다.스프링에서 Resource 어노테이션 추가 시, 동작하는 순서는 아래와 같다. name 속성 값과 동일한 빈 객체를 찾고 해당 객체를 사용한다. name 속성 값이 없을 경우, 동일 타입의 객체를 검색하고 1개일 경우, 해당 객체를 사용한다. name 속성 값이 없고 동일 타입을 갖는 빈 객체가 2개 이상일 경우, 이름이 같은 빈 객체를 찾는다. name 속성 값이 없고 동일 타입을 갖는 빈 객체가 2개 이상이면서 같은 이름을 가진 빈 객체가 없는 경우 @Qualifier(한정자) 값의 빈 객체를 찾는다. 모두 해당하지 않으면 Exception이 발생한다. 4. 자동 주입과 명시적 의존 주입 간의 관계자동 주입과 명시적 의존 주입(constructor-arg, property 태그)을 함께 사용할 수 있다.이러한 경우 자동 주입보다 명시적 의존 주입을 우선한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"스프링 DI(의존주입)-3","slug":"programming-spring-study-005","date":"2018-10-03T12:09:43.000Z","updated":"2018-10-08T14:01:00.000Z","comments":true,"path":"2018/10/03/programming-spring-study-005/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/03/programming-spring-study-005/","excerpt":"","text":"1.의존 자동 주입-1스프링은 프레임워크 자체에서 자동으로 의존 객체를 찾아 주입해주는 기능을 지원한다.설정 방법 또한 간단하다. 설정 XML 내에 &lt;context:annotation-config/&gt; 추가 의존 주입 대상에 @Autowired 어노테이션 작성 @Autowired 어노테이션을 이용한 의존 자동 주입에도 여러가지 방법이 존재한다. 생성자 자동 주입123456789public calss MemberRegisterService &#123; private MemberDao memberDao; @Autowired public MemberRegisterService(MemberDao memberDao) &#123; // 의존 주입 this.memberDao = memberDao; &#125; ...&#125; 위와 같이 생성자에 @Autowired 어노테이션을 추가하여 의존 객체를 자동 주입할 수 있다. 필드 자동 주입123456789public calss MemberRegisterService &#123; @Autowired private MemberDao memberDao; // 의존 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; ...&#125; 이와 같이 필드에 @Autowired 어노테이션을 추가하는 방법이 있다. 설정 메소드 자동 주입123456789public calss MemberPrinter &#123; private MemberPrinter printer; @Autowired public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; 마지막으로 설정 메소드에 어노테이션을 추가하는 방법도 있다. 이와 같은 방법으로 의존 객체를 자동 주입할 경우 앞서 사용했던 constructor-arg나 property 태그를 사용하지 않아도 된다. 12345&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.MemberRegisterService\"&gt;&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 2. Autowired의 기본적인 특성그렇다면 스프링은 어떻게 객체를 자동으로 주입할 수 있을까?우선 스프링은 같은 유형에 속하는 빈 객체를 검색해 주입 대상을 선택한다.예를 들어 B라는 클래스는 A를 상속 받아 만들어졌다고 가정하자B 클래스가 Bean에 등록되있으면서 A 클래스를 생성/설정하는 생성자 혹은 필드, 설정 메소드에 Autowired 어노테이션을 추가한다면B 클래스는 A 클래스를 상속 받아 생성된 같은 유형이므로 B 클래스를 자동 할당해준다. 만약 동일한 유형의 빈 객체 두 개가 등록 되어 있다면 어떻게 될까?이런 경우 어떤 클래스를 할지 판단할 수 없어 ‘NoUniqueBeanDefinitionException’이 발생한다. 이러한 문제를 해결하기 위해 @Qualifier 어노테이션을 사용할 수 있다. 3. Qualifier를 이용한 의존 주입 객체 선택Qualifier 어노테이션을 이용하면 동일한 유형의 클래스 다수가 Bean에 등록되어 있더라도 주입할 의존 객체를 개별적으로 선택할 수 있다. 설정 XML 내 등록 된 Bean에 한정자 태그(qualifier)와 값을 설정한다. Autowired 적용 대상에 Qualifier을 추가하고 한정자 값을 입력한다. 1234567&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt; &lt;qualifier value=\"sysout\" /&gt; // 한정자 값 설정&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter2\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 위와 같이 동일한 유형의 객체가 Bean에 등록한 후 한정자 값을 설정한다. 12345678910public calss MemberPrinter &#123; private MemberPrinter printer; @Autowired @Qualifier(\"sysout\") public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; Autowired 어노테이션과 함께 Qualifier 어노테이션을 기입하면 객체를 선택 주입할 수 있다. 한정자 값을 잘못 기입하면 Exception을 발생시키니 유의해야한다. 4. Autowired 필수 여부 지정만약 Autowired 어노테이션을 추가했지만 Bean이 등록되어 있지 않다면 어떻게 될까?당연하게도 스프링 컨테이너 생성 시, Exception이 발생한다. 이를 막기 위해 Autowired 어노테이션의 required(필수) 여부를 변경할 수 있다. 12345public calss MemberPrinter &#123; @Autowired(required=false) private MemberPrinter printer; // 의존 주입했지만 Bean이 등록되지 않았다. ...&#125; 위와 같이 필수 여부를 false 처리할 경우 컨테이너 생성 시, Exception이 발생하지 않는다.하지만 이는 필수 여부이지 의존 객체를 주입하지 않는다는 의미는 아니다.required=false로 처리했더라도 같은 유형의 객체가 등록되어 있다면 객체는 자동 주입된다.단순히 객체가 존재하지 않아도 Exception을 발생시키지 않는 설정이라고 생각하면 편하다. 5. Autowired의 동작 순서Autowired의 기본적인 특성에 대해 알아봤으며 마지막으로 동작 순서로 정리한다.스프링에서 Autowired 어노테이션 추가 시, 동작하는 순서는 아래와 같다. 동일 타입의 객체를 검색하고 1개일 경우, 해당 객체를 사용한다.Qualifier가 입력된 경우 Qualifier 설정 값이 동일한 빈을 찾는다. 타입이 같은 빈이 2개 이상일 경우, Qualifier 설정 값이 동일한 빈을 찾는다. 타입이 같은 빈이 2개 이상이며 Qualifier 설정 값이 없는 경우,이름이 같은 빈 객체를 찾는다. 모두 해당하지 않으면 Exception이 발생한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"프로퍼티(Property)란?","slug":"programming-spring-study-004","date":"2018-09-18T14:46:16.000Z","updated":"2018-10-03T15:46:02.000Z","comments":true,"path":"2018/09/18/programming-spring-study-004/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/18/programming-spring-study-004/","excerpt":"","text":"프로퍼티(Property)란?프로퍼티를 알기 전에 자바빈을 알아야 한다.자바빈즈은 JavaBean 규약에 따라 작성된 자바 클래스이다.자바빈즈 규약은 재사용 가능한 객체를 빈(Bean)으로 명명하고 있다. 자바빈 클래스 외부에서 필드에 접근할 경우 반드시 메소드를 통해 접근해야한다.여기서 프로퍼티는 객체와 관련하여 이름 붙여진 속성을 말하며 빈이 관리하는 데이터를 의미한다. 프로퍼티 값을 구하는 메소드는 get으로 시작한다. 프로퍼티 값을 변경하는 메소드는 set으로 시작한다. get과 set 뒤에는 프로퍼티의 이름 첫 글자를 대문자로 바꾼다. set 메소드는 1개의 파라미터를 갖는다. 프로퍼티는 위와 같은 명명 규칙을 가지고 있으며 흔히들 getter/settet를 묶어서 그냥 프로퍼티라고 부른다. 자바빈즈의 빈과 스프링의 빈은 같은 것으로 스프링의 빈이 자바빈즈의 빈을 따라한 것이다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"PROPERTY","slug":"PROPERTY","permalink":"https://lee-jung-hoon.github.io/tags/PROPERTY/"}]},{"title":"스프링 DI(의존주입)-2","slug":"programming-spring-study-003","date":"2018-09-18T12:46:16.000Z","updated":"2018-10-03T15:45:28.000Z","comments":true,"path":"2018/09/18/programming-spring-study-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/18/programming-spring-study-003/","excerpt":"","text":"1. 스프링에서의 의존주입 방식 생성자 방식 기본적인 의존주입 방식은 ‘생성자 방식’이 있다.생성자를 통해 의존 객체를 주입 받아 필드에 할당하는 방식이다.123456789101112131415public class MemberRegisterService &#123; private MemberDao memberDao; // 의존 객체를 할당해줄 생성자 메소드 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public void regist(RegisterRequest req) &#123; // 주입 받은 의존 객체를 메소드에서 사용함 Member member = memberDao.selecetByEmail(req.getEmail()); ... memberDao.insert(newMember); &#125;&#125; 12345&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;constructor-arg ref=\"memberDao\" /&gt;&lt;/bean&gt; 위와 같이 constructor-arg 태그를 이용해 생성자에 의존 객체를 주입한다.만약 생성자에 전달해야할 의존 객체가 두 개 이상이라면 constructor-arg 태그를 순서에 맞게 추가하고 생성자의 매개변수를 추가한다. 1234567891011public class MemberRegisterService &#123; private MemberDao memberDao; private MemberPrint memberPrint; // 의존 객체를 할당해줄 생성자 메소드 public MemberRegisterService(MemberDao memberDao, MemberPrint memberPrint) &#123; this.memberDao = memberDao; this.memberPrint = memberPrint; &#125; ...&#125; 1234567&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;constructor-arg ref=\"memberDao\" /&gt; &lt;constructor-arg ref=\"memberPrint\" /&gt;&lt;/bean&gt; 설정 메소드 방식 다음으로는 ‘설정 메소드 방식’이 있다.set으로 시작하는 프로퍼티 설정 메서드를 통해 의존 객체를 주입하는 방식이다.** 프로퍼티에 대한 내용은 별도로 포스트 12345678910111213public class MemberRegisterService &#123; private MemberDao memberDao; private MemberPrint memberPrint; public void setMemberDao(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public void setMemberPrint(MemberPrint memberPrint) &#123; this.memberPrint = memberPrint; &#125; ...&#125; 1234567&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;property ref=\"memberDao\" name=\"memberDao\"/&gt; &lt;property ref=\"memberPrint\" name=\"memberPrint\"/&gt;&lt;/bean&gt; 설정 메소드 방식은 각 필드의 getter/setter를 가지며 태그를 이용해 객체를 주입한다. 그렇다면 이 두 가지 방식 중 어떤 방식이 좋은 방식일까? 결론은 양쪽 모두 장단점이 존재한다. 생성자 방식은 빈 객체 생성 시점에 모든 의존 객체가 주입되지만주입해야할 객체가 많을 경우 생성자의 파라미터가 많아지고 가독성이 떨어진다. 반대로 설정 메소드 방식은 property 태그의 name 속성(attribute)를 통해해당 의존 객체에 대해 알아볼 수 있으므로 가독성이 좋은 편이다. 하지만 설정 메소드 방식의 경우 property 태그가 누락될 경우 객체 사용 시점에 NullPointException을 발생 시킬 수 있다. 2. 객체 주입 시 기본 값 설정생성자 방식과 설정 메소드 방식을 통해 의존 객체를 주입하는 방법을 알 수 있었다.이와 같은 객체 주입 시 기본 데이터 값을 설정해야하는 경우 value 속성을 이용한다. 123456789101112131415161718public class VersionPrint &#123; private int majorVersion; private int minorVersion; // setter public void setMajorVersion(int majorVersion) &#123; this.majorVersion = majorVersion; &#125; // setter public void setMinorVersion(int minorVersion) &#123; this.minorVersion = minorVersion; &#125; public void print() &#123; System.out.println(\"Version Num : \" + majorVersion + \".\" + minorVersion); &#125;&#125; 123456&lt;bean id=\"versionPrint\" class=\"kr.co.jhdev.Version.versionPrint\"&gt; &lt;property name=\"majorVersion\" value=\"3\"/&gt; &lt;property name=\"minorVersion\"&gt; &lt;value&gt;7&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 생성자, 설정 메소드 두 방식 모두 value 속성을 통해 기본 값을 설정한다.value 속성이 아닌 태그를 통해 중첩 사용하는 방법도 존재한다. 여기서 주목해야할 점은 해당 기본 값의 데이터 타입을 알 수 없음에도 정상 동작한다.그 이유는 스프링이 알아서 데이터 타입으로 변환하여 처리하기 때문이다. 3. 두 개 이상의 설정파일 사용하기개발을 하다보면 설정 관련 파일이 비대해질 수 있다.이럴 경우 가독성도 떨어지게 되고 유지보수에 있어 어려움을 겪을 수 있다. 해당 문제점을 개선하기 위해선 설정 파일을 성격에 따라 나누어야 한다.설정 파일을 나눈 경우 GenericXmlApplicationContext 클래스의 생성자를 이용하는 방법과 import 태그를 이용하는 방법이 있다. GenericXmlApplicationContext의 생성자를 이용하는 방식기본적으로 GenericXmlApplicationContext 클래스의 생성자는 가변 인자이므로 배열을 이용할 수 있다. 12String[] conf = &#123;\"classpath:conf1.xml\", \"classpath:conf2.xml\"&#125;;ctx = new GenericXmlApplicationContext(conf) 위와 같이 설정 xml 파일 경로를 배열에 담고 생성자에 전달하는 방식이다. import 태그를 이용하는 방식import 태그를 이용하는 방식의 경우 설정파일을 분리 한 후 import 태그를 이용해한 설정 파일에 다른 설정 파일 내용을 삽입해주는 방법이다. 123456789&lt;import resource=\"classpath:conf2.xml /&gt;&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;property ref=\"memberDao\" name=\"memberDao\"/&gt; &lt;property ref=\"memberPrint\" name=\"memberPrint\"/&gt;&lt;/bean&gt; 위와 같이 설정 파일 내용을 import 태그를 통해 다른 설정 파일에 추가하여 함께 사용할 수 있다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"IOC","slug":"IOC","permalink":"https://lee-jung-hoon.github.io/tags/IOC/"}]},{"title":"서비스 로케이터란?","slug":"programming-java-servicelocator-002","date":"2018-09-16T06:22:44.000Z","updated":"2018-09-16T07:10:00.000Z","comments":true,"path":"2018/09/16/programming-java-servicelocator-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/programming-java-servicelocator-002/","excerpt":"","text":"스프링을 공부하던 중 의존 해결을 위한 방법으로 서비스 로케이터와 DI가 있다고 배웠다. 하지만 서비스 로케이터를 제대로 설명하는 경우는 별로 없는듯 하다. 많은 부분에서 알지는 못하지만 이해한 곳까지는 적어보려 한다. 서비스 로케이터(Service Locator)는 마틴 파울러에 의해 유명해진 디자인 패턴이다. JNDI를 생각하면 빠르게 이해할 수 있을 듯 하다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceLocator &#123; private InitialContext ic; private Map cache; private static ServiceLocator me; static &#123; me = new ServiceLocator(); &#125; private SerivceLocator() &#123; cache = Collections.synchronizedMap(new HashMap()); &#125; public InitialContext getInitialContext() throws Exception &#123; try&#123; if( ic == null) &#123; ic = new InitialContext(); &#125; &#125; catch (Exception e) &#123; throw e; &#125; return ic; &#125; public static ServiceLocator getInstance()&#123; return me; &#125; public EJBLocalHome getLocalHome(String jndiHomeName) throws Exception &#123; EJBLocalHome home = null; try&#123; if (cache.containsKey(jndiHomeName)) &#123; home = (EJBLocalHome)cache.get(jndiHomeName); &#125; else&#123; home = (EJBLocalHome)getInitialContext().lookup(jndiHomeName); cache.put(jndiHomeName, home); &#125; &#125; catch (NamingException ne) &#123; throw new Exception(ne.getMessage()); &#125; catch (Exception e) &#123; throw new Exception(e.getMessage()); &#125; return home; &#125;&#125;; 서비스 로케이터 패턴은 위의 소스와 같이 cache에 담아두고 객체가 필요할 경우메모리에서 바로바로 찾아서 제공하는 구조를 가진다. cache에서 키를 찾아 존재하는 경우, 반환하고 없는 경우 cache에 담아주는 형태를 가진다. 인용 https://code.i-harness.com/ko-kr/q/17c515Dependency Injection과 Service Locator의 차이점은 무엇입니까? 두 패턴 모두 종속성 반전 원리를 구현하는 데 적합합니다. Service Locator 패턴은 공용 인터페이스를 변경하지 않고 전체 디자인을 느슨하게 만들기 때문에 기존 코드베이스에서 사용하기가 더 쉽습니다. 이와 동일한 이유로 Service Locator 패턴을 기반으로하는 코드는 Dependency Injection을 기반으로하는 동일한 코드보다 읽기 쉽지 않습니다. Dependency Injection 패턴은 클래스 (또는 메소드)가 가질 종속성 서명 이후에 명확하게 나타냅니다. 이러한 이유로 결과 코드는보다 깨끗하고 읽기 쉽습니다. 읽어 볼만한 링크http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"DeginePattern","slug":"DeginePattern","permalink":"https://lee-jung-hoon.github.io/tags/DeginePattern/"},{"name":"ServiceLocator","slug":"ServiceLocator","permalink":"https://lee-jung-hoon.github.io/tags/ServiceLocator/"}]},{"title":"JEUS8, WEBTOB5 라이센스 적용 방법","slug":"was-jeus-license-001","date":"2018-09-16T01:51:08.000Z","updated":"2018-09-16T04:30:22.000Z","comments":true,"path":"2018/09/16/was-jeus-license-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/was-jeus-license-001/","excerpt":"","text":"해당 문서는 JEUS와 웹투비 라이센스 파일을 발급 받은 상태를 전제로 합니다. JEUS 라이센스 적용 방법 JEUS 설치 경로로 이동합니다. ($JEUS_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license license.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. jeusadmin 명령어를 이용하여 라이센스 정보를 확인합니다. jeusadmin -licensedue jeusadmin -licenseinfo JEUS를 재기동합니다. jdown -&gt; jboot 라이센스 파일은 .dat 확장자로 되어있을 경우 확장자를 제거하여야 합니다. ftp를 이용하여 업로드 하기 이전에 확장자를 제거할 한 후 업로드 할 경우 디렉토리로 인식하므로 업로드 후 확장자를 제거합니다. (cp license.dat license) Demo 라이센스의 경우 licensedue 명령어 입력 시, ‘ㅇㅇ Days Left’라는 유효기간에 대한 코멘트가 나타나며, 정식 라이센스의 경우 ‘unlimited’ 코멘트가 나타납니다. Demo 라이센스의 경우 licenseinfo 명령어 입력 시, Edition 부분에 ‘Demo License’ 문구가 나타나며 CPU가 ‘unlimited’라 출력됩니다. 정식 라이센스의 경우 ‘Demo’ 문구가 없으며 신청한 CPU 코어수와 HOST NAME이 나타납니다. JEUS 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. manager server를 shutdown 상태로 전환하고nodemanager down -&gt; das down -&gt; das boot -&gt; nodemanager boot 순으로 진행합니다. WEBTOB 라이센스 적용 방법 WEBTOB 설치 경로로 이동합니다. ($WEBTOB_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license.dat license.dat.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. wsconfig 파일을 컴파일 합니다.($WEBTOB_HOME/config 경로에서 ‘wscfl -i http.m’) wsadmin 명령어를 이용하여 라이센스 정보를 확인합니다. wsadmin -i [라이센스 파일명] WEBTOB를 재기동합니다. wsdown -&gt; wsboot wsadmin 명령어를 이용하여 적용된 라이센스 정보를 확인합니다. wsadmin 입력 후 wi 재 입력 JEUS와 달리 .dat 확장자 그대로 적용합니다. wsadmin -i [라이센스 파일명] 입력 시, License Type이 ‘DEMO’로 출력될 경우 데모 라이센스이며 정식 라이센스인 경우 ‘REAL’이 출력됩니다. WEBTOB 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. wsadmin 입력 후 wi 재 입력 시, Demo 라이센스의 경우 ‘DEMO’라 출력되며 정식 라이센스인 경우 ‘REAL’이 출력됩니다.","categories":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/"},{"name":"JEUS","slug":"WAS/JEUS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/JEUS/"}],"tags":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/tags/WAS/"},{"name":"JEUS","slug":"JEUS","permalink":"https://lee-jung-hoon.github.io/tags/JEUS/"},{"name":"WEBTOB","slug":"WEBTOB","permalink":"https://lee-jung-hoon.github.io/tags/WEBTOB/"},{"name":"LICENSE","slug":"LICENSE","permalink":"https://lee-jung-hoon.github.io/tags/LICENSE/"}]},{"title":"maven-4.0.0.xsd에서 에러날 경우","slug":"programming-spring-error-003","date":"2018-09-09T12:59:01.000Z","updated":"2018-09-16T04:02:50.000Z","comments":true,"path":"2018/09/09/programming-spring-error-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-error-003/","excerpt":"","text":"pom.xml 프로젝트 태그 내 maven-4.0.0.xsd에서 에러가 발생할 경우위와 같은 에러가 발생할 경우 https://mvnrepository.com/artifact/org.apache.maven/maven-plugin-api 해당 URL에 접속하여 안정적인 버전의 maven dependency를 복사하여 pom.xml에 추가합니다. 해당 프로젝트 오른쪽 우클릭 -&gt; Run As -&gt; Maven Clean, Maven Install 실행 해당 프로젝트 오른쪽 우클릭 -&gt; Maven -&gt; Update Project(Alt + F5) 실행","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"MAVEN","slug":"MAVEN","permalink":"https://lee-jung-hoon.github.io/tags/MAVEN/"}]},{"title":"JDK 설치 및 환경변수 설정","slug":"programming-java-install-001","date":"2018-09-09T11:42:02.000Z","updated":"2018-09-09T14:49:32.000Z","comments":true,"path":"2018/09/09/programming-java-install-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-java-install-001/","excerpt":"","text":"1. JDK의 계층 구조 JVM(JAVA Virtual Machine) 자바 가성 머신의 줄임말으로써 JAVA와 OS의 중개자 역할을 한다. JVM이 있으므로 인해 자바는 OS에 구애받지 않는 ‘확장성’이라는 장점을 가지게 된다. 그 외에도 가비지 컬렉션(Garbage Collection), 메모리 관리등을 수행한다. JRE(JAVA Runtime Environment) 자바의 기능들을 수행하는 API를 감싸고 있는 실행환경 단순 프로그램 실행만을 위해서는 JRE 설치로 충분하다. JDK(JAVA Development Kit) 자바의 실행환경을 포함하는 자바 개발환경을 의미한다. 자바 개발을 위해서는 JDK가 설치되어야 한다. 2. JDK 설치http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 상단의 JDK SE 다운로드 URL에 접속하여 본인 개발 환경에 맞는 설치파일을 다운로드 및 설치를 진행한다. 3. JAVA 환경변수 java.exe : JVM 실행 파일 javac.exe : 컴파일러 JAVA_HOME 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 변수 이름 : JAVA_HOME 변수 값 : JAVA 설치 경로 PATH 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 PATH 변수에 %JAVA_HOME%\\bin을 추가 JAVA_HOME 변수에 설정한 JAVA 설치 경로 하위의 bin 폴더를 PATH 추가해주는 것입니다.** 리눅스나 유닉스 계열은 profile에 설정 4. 확인 명령 프롬프트에 ‘java -version’, ‘javac -version’를 입력하여 버젼을 확인한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"JDK - JRE - JVM","slug":"JDK-JRE-JVM","permalink":"https://lee-jung-hoon.github.io/tags/JDK-JRE-JVM/"}]},{"title":"스프링 DI(의존 주입)","slug":"programming-spring-study-002","date":"2018-09-09T09:46:16.000Z","updated":"2018-09-16T09:06:48.000Z","comments":true,"path":"2018/09/09/programming-spring-study-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-002/","excerpt":"","text":"스프링의 DI(의존 주입)을 보기 전에 먼저 스프링의 목적을 알아볼 필요가 있다. 2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제 ‘무엇때문에 자바 엔터프라이즈 프로젝트는 실패하는가?’ 그에 대한 답은 바로 시스템 개발이 복잡하다는 것이었다. 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리하는 시스템 이러한 시스템은 비즈니스 로직 구현만이 아닌 보안, 안정성, 확장성, 성능을 모두 고려해서 개발해야한다. 결국 비즈니스 로직, 안정성, 확장성, 성능에 더해 추후 바뀔지 모르는 비즈니스 로직에 대한 유지보수 및 수정까지 고려해야하는 큰 어려움에 부딪혔다 1. 의존이란 DI(Dependency Infjection) 의존 관계 주입이라는 말로 해석 할 수 있다. 표준국어대사전에 의하면 ‘의존’이란 다른 것에 의지하여 존재하는 즉, 의존관계란 변경에 의해 영향을 받는 관계를 의미한다. 1234567891011121314151617public class MemberRegisterService &#123; // new 연산자를 이용해서 MemeberDao의 인스턴스를 생성한다. 이를 '보통객체'라 부른다. private MemberDao memberDao = new MemberDao(); public void regist(RegisterRequest req) &#123; // 이메일로 회원 데이터(Member)조회 Member member = memberDao.selectByEmail(req.getEmail()); if (member != null) &#123; // 같은 이메일을 가진 회원이 이미 존재하면 익셉션 발생 throw new AlreadyExistingMemberException(\"dup email : \" + req.getEmail()); &#125; // 같은 이메일을 가진 회원이 존재하지 않으면 DB에 삽입 Member newMember = new Member(req.getEmail(), req.getPassword(), req.getName(), new Date()); memberDao.insert(newMember); &#125;&#125; 위 코드는 전달 받은 회원 객체 내 이메일 주소가 현재 회원 DB 테이블 내에 존재하는 경우익셉션을 발생시키고 같은 이메일 주소를 가진 회원이 존재하지 않는 경우 DB에 INSERT 시키는 간단한 로직을 가지고 있다. 이와 같이 한 클래스에서 다른 클래스의 메소드를 실행하는 경우를 ‘의존’한다고 말한다. 의존은 변경에 의해 영향을 받는 관계를 의미한다. ex) MembaerDao의 insert()메소드의 이름을 insertMemeber()라고 변경하면 이 메소드를 사용하는 타 클래스들도 영향을 받는다. 여기서 알고 가면 좋은 한 가지.객체지향 프로그래밍의 기초 개념 중 하나는 관심사의 분리 라는 것이다. 단순히 DB INSERT하고 SELECT하는 메소드를 만들때 위와 같은 코드를 만들 수 있지만리소스의 낭비나 환경의 변화에 바로 대응하기 위해선 관심사의 분리가 중요하다. 1234567891011121314151617public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Class.forName(\"oracle.jdbc.driver.OracleDriver\"); Connection c = DriverManager.getConnection( \"jdbc:oracle:thin:@127.0.0.1:1521:orcl\", \"PPS_DB\", \"PPS123\"); return c;&#125; ...public void add(User user) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; public void get(String id) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; 위와 같이 중복 혹은 의존 관계인 코드를 분리하여 의존을 제거할 수 있다.DB의 종류가 바뀌거나 계정을 바꿔야할 경우 getConnection 메소드만 수정하면 끝! 의존 객체를 구하는 방법에는 DI와 서비스 로케이터가 있다. 서비스 로케이터에 관련하여 별도로 포스트 예정 DI는 의존하는 객체를 직접 생성하지 않고 의존 객체를 전달받는 방식을 사용한다. 12345678910111213Member dao = new MemberDao();// 의존 객체를 생성자를 통해 주입처리MemberRegisterService service = new MemberRegisterService(dao);...public class MemberRegisterService &#123; private MemberDao memberDao; // MemberRegisterServeice가 의존하고 있는 MemberDao 객체를 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125;...&#125; 위와 같이 의존 객체를 직접 생성하지 않고 생성자를 통해 전달 받으므로 DI(의존 주입) 패턴을 따르고 있다. 12345678910111213public static void main(String[] args) &#123; MemberAssembler assembler = new MemberAssembler(); Member member = new Member(\"jh4327\", \"4327\"); RegisterService registerService = assembler.getRegisterService(); registerService.register(member); member.setPassword(\"1234\"); PwChangeService pwChangeService = assembler.getPwChangeService(); pwChangeService.update(member);&#125; 위와 같이 사용자를 입력하고 비밀번호를 수정하는 구조를 가진 프로세스가 있을 때 1234567891011121314151617181920212223242526272829303132333435public class MemberAssembler &#123; private MemberDao memberDao; private RegisterService registerService; private PwChangeService pwChangeService; public MemberAssembler() &#123; memberDao = new MemberDao(); registerService = new RegisterService(memberDao); pwChangeService = new PwChangeService(memberDao); &#125; public MemberDao getMemberDao() &#123; return memberDao; &#125; public void setMemberDao(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public RegisterService getRegisterService() &#123; return registerService; &#125; public void setRegisterService(RegisterService registerService) &#123; this.registerService = registerService; &#125; public PwChangeService getPwChangeService() &#123; return pwChangeService; &#125; public void setPwChangeService(PwChangeService pwChangeService) &#123; this.pwChangeService = pwChangeService; &#125;&#125; 위와 같은 객체 조립기를 통해 DAO 의존 주입이 가능하다.하나의 동일한 객체를 각 서비스에 주입시켜주는 구조.최초 생성(로드)할 때 DAO 객체를 다른 객체가 생성될 때 모두 주입하는 것이다.즉 Service들은 Dao에 의존하고 있으며 의존 주입 관계이다. 이걸 스프링 DI로 변경한다면?123456789&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"registerService\" class=\"kr.co.jhdev.MemberService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"pwChangeService\" class=\"kr.co.jhdev.PwChangeService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 앞서 개발한 객체 조립기를 xml 스프링 컨테이너로 변경한다.registerService와 pwChangeService는 memberDao를 참조하도록 한다.이로써 최초 로드시 서비스들과 dao의 의존관계가 설정된다. 1234567891011121314// MemberAssembler assembler = new MemberAssembler();GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:applicationContext.xml\");Member member = new Member(\"jh4327\", \"4327\");// RegisterService registerService = assembler.getRegisterService();RegisterService registerService = ctx.getBean(\"registerService\", RegisterService.class);registerService.register(member);member.setPassword(\"1234\");// PwChangeService pwChangeService = assembler.getPwChangeService();PwChangeService pwChangeService = ctx.getBean(\"pwChangeService\", PwChangeService.class);pwChangeService.update(member); 스프링 컨테이너에 등록한 bean과 객체들 간 의존 관계를 이용하여 위와 같은 코드로 변경될 수 있다.직접 주입하지 않고 스프링 컨테이너를 통해 주입하고 getBean을 통해 불러오기만 하면 된다.지금까진 xml을 이용한 의존 주입을 해왔다. 다음 해당 포스팅에선 어노테이션을 이용한 방법에 대해 설명하도록 한다. 결국 의존 주입은 관심사의 분리를 통해 유지보수와 수정을 용이하게 하기 위함에 목적이 있다. 초보 웹 개발자를 위한 스프링 4 프로그래밍 입문(최범균 지음) 토비의 스프링 3.1(이일민 지음)","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"IOC","slug":"IOC","permalink":"https://lee-jung-hoon.github.io/tags/IOC/"}]},{"title":"java-spring-study-001","slug":"programming-spring-study-001","date":"2018-09-09T09:46:11.000Z","updated":"2018-09-09T11:46:40.000Z","comments":true,"path":"2018/09/09/programming-spring-study-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-001/","excerpt":"","text":"","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[]},{"title":"테이블스페이스 용량 확인 쿼리","slug":"dbms-oracle-tablespace-001","date":"2018-09-09T09:26:25.000Z","updated":"2018-09-09T09:49:52.000Z","comments":true,"path":"2018/09/09/dbms-oracle-tablespace-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/dbms-oracle-tablespace-001/","excerpt":"","text":"업무를 하다보면 계정의 테이블스페이스의 현재 상태를 체크해야할 일이 생깁니다. 예를 들어 데이터를 이관해야하는 경우, AUTOEXTENSIBLE가 YES일지라도 테이블스페이스의 현재 상태는 체크해주는게 좋습니다. 123456789101112131415SELECT SUBSTR(A.TABLESPACE_NAME,1,30) TABLESPACE, ROUND(SUM(A.TOTAL1)/1024/1024,1) \"총 용량(MB)\", ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1) \"사용량(MB)\", ROUND(SUM(A.SUM1)/1024/1024,1) \"잔여용량(MB)\", ROUND((ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1))/ROUND(SUM(A.TOTAL1)/1024/1024,1)*100,2) \"사용률(%)\"FROM (SELECT TABLESPACE_NAME,0 TOTAL1,SUM(BYTES) SUM1,MAX(BYTES) MAXB,COUNT(BYTES) CNT FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME UNION SELECT TABLESPACE_NAME,SUM(BYTES) TOTAL1,0,0,0 FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME) AGROUP BY A.TABLESPACE_NAMEORDER BY TABLESPACE; 해당 쿼리 실행 시 총 용량과 현재 사용량, 잔여용량, 사용률 등을 확인할 수 있습니다.","categories":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/"},{"name":"ORACLE","slug":"DBMS/ORACLE","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/ORACLE/"}],"tags":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/tags/DBMS/"},{"name":"ORACLE","slug":"ORACLE","permalink":"https://lee-jung-hoon.github.io/tags/ORACLE/"},{"name":"TABLESPACE","slug":"TABLESPACE","permalink":"https://lee-jung-hoon.github.io/tags/TABLESPACE/"}]}]}