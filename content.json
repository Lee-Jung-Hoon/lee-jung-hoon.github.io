{"meta":{"title":"DevJH","subtitle":"Writed by JH, IT Blog","description":"IT Blog","author":"Lee Jung Hoon","url":"https://lee-jung-hoon.github.io"},"pages":[],"posts":[{"title":"AOP란 무엇일까? - 02","slug":"programming-spring-study-009","date":"2018-11-09T12:34:34.000Z","updated":"2018-11-10T00:08:43.874Z","comments":true,"path":"2018/11/09/programming-spring-study-009/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/09/programming-spring-study-009/","excerpt":"","text":"AOP의 핵심 용어 정리","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"AOP","slug":"AOP","permalink":"https://lee-jung-hoon.github.io/tags/AOP/"}]},{"title":"도커(Docker) 기본 사용법 및 몽고 DB 설치","slug":"docker-003","date":"2018-11-07T02:17:48.000Z","updated":"2018-11-09T05:33:56.550Z","comments":true,"path":"2018/11/07/docker-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/07/docker-003/","excerpt":"","text":"앞선 포스트를 통해 도커가 무엇이며 어떻게 설치하는지에 대해 알아봤습니다.이번엔 도커의 가장 기본적인 사용법에 대해 알아보도록 하겠습니다. 본격적으로 도커의 사용법 배우기 전에 핵심 개념 중 하나인 이미지(Image)에 대해 알아보고 가겠습니다. 도커에서 이미지(Image)란?도커 이전에 VirtualBox나 VMWare와 같은 가상 머신 툴을 사용해 보신 분들이라면 이미지라는 개념에 대해 익숙 하실겁니다.가상 머신 툴의 경우 하이퍼바이저를 통해 부팅 되는 게스트 운영체제 자체를 이미지 파일로 특정 경로에 저장하고 있으며 이를 배포하기도 합니다.해당 이미지 파일을 임포트하여 사용할 경우 동일한 환경을 구성할 수 있죠. 도커에서도 이와 유사한 개념입니다. 단지 다른 점이라면 가상 머신 툴의 이미지가 게스트 운영체제 자체라면 도커의 이미지는 필요한 라이브러리만으로 구성되어있다는 점입니다.그리고 도커는 이미지를 실행하는 것이 아닌 이미지를 기반으로 컨테이너를 만들어 실행한다는 점이 다릅니다. 그리고 도커는 이러한 이미지들을 공유하기 위한 도커 허브라는 웹 호스팅 서비스를 제공합니다.깃과 깃허브의 관계와 비슷하다고 볼 수 있습니다.다른 점이라면 깃은 리누스 토발즈가 만들고 깃허브는 깃허브 팀이 만들었지만 도커와 도커 허브는 모두 도커 팀에서 만들었다는 점입니다. 이번 포슽트에선 몽고 DB를 설치하며 기본적인 도커 사용법을 알아보고자 합니다. 1. 도커 허브에서 몽고 DB 이미지 검색제일 먼저 도커 허브에서 필요한 이미지를 검색합니다.mongo를 검색한 결과 도커 허브에서 제공하는 몽고DB 정식 이미지가 출력됩니다.도커 허브를 통하는 방법 외에도 docker search [이미지 이름]:[태그]를 통해 검색 할 수 있습니다. 2. 몽고 DB 이미지 내려 받기도커 허브를 통해 알게 된 docker pull [이미지 이름] 명령어를 입력합니다.몽고 DB 도커 이미지를 내려받는 명령어입니다.태그를 입력하지 않을 경우 latest로 설정되며 최신 버전을 내려받습니다. 3. 내려받은 도커 이미지 목록 확인이미지가 내려받아졌다면 docker images [이미지 이름] 명령어를 입력하여 이미지 목록을 확인합니다.이미지 이름을 입력하지 않을 경우 모든 이미지 목록이 출력됩니다. 4. 컨테이너 실행 및 프로세스 확인이미지를 이용하여 컨테이너를 생성하고 실행합니다.docker run --name [프로세스명] -p [포트포워딩] -d [이미지명]\u001d 명령어 입력 시 이미지를 컨테이너로 만들고 해당 컨테이너를 실행합니다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"}]},{"title":"Mac(맥 OS)에 도커 설치하기","slug":"docker-002","date":"2018-11-06T08:35:35.000Z","updated":"2018-11-07T05:29:15.258Z","comments":true,"path":"2018/11/06/docker-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/docker-002/","excerpt":"","text":"앞서 도커란 무엇인가에 대해 살펴 보았습니다. 이번엔 도커를 설치해보고자 합니다. 현재 PC가 Mac(맥 OS)이므로 해당 환경에 맞춰 진행하도록 하겠습니다.Windows 환경에서의 설치 또한 추후 업로드 할 예정입니다. 1. 도커 홈페이지 접속 도커 공식 홈페이지에 접속하여 [Get Started]를 선택하시면 운영체제별 설치 페이지가 나타납니다. 과거엔 CentOS나 Ubuntu 등의 리눅스 운영체제에 apt-get, yum과 같은 패키지 다운로더를 통해서만 설치가 가능했는데현재는 다양한 운영체제로 확장되었습니다.(물론 Windows의 경우 가상머신 툴 등이 포함되어 다소 차이가 있습니다. 추후 업로드 예정) 2. 도커 설치 파일 다운로드 및 설치 진행도커 홈페이지에서 Docker for Mac(도커 디스크 이미지)를 다운 받아 그대로 설치를 진행합니다.별다른 어려운 부분은 없습니다.GUI이기 때문에 단순 클릭 몇 번이면 설치가 완료됩니다. 3. 설치 확인마지막으로 터미널에 접속하여 docker --version을 입력하여 설치된 도커의 버전을 확인합니다.해당 명령어를 입력 했을 때, 버전이 출력된다면 일단 도커 엔진이 설치된 상태입니다. 다음 포스트에서는 도커의 기본적인 명령어와 사용법에 대해 알아보겠습니다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"},{"name":"설치","slug":"설치","permalink":"https://lee-jung-hoon.github.io/tags/설치/"}]},{"title":"도커(Docker)란?","slug":"docker-001","date":"2018-11-06T08:35:34.000Z","updated":"2018-11-07T05:29:48.895Z","comments":true,"path":"2018/11/06/docker-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/docker-001/","excerpt":"","text":"도커는 사실 새로운 개념의 기술은 아니다. 도커 이전에 리눅스 컨테이너(LXC)라는 기술이 존재했다. 리눅스 컨테이너는 리눅스 커널에 포함되어 있었던 기술로 cgroups와 namespace를 활용하여 cpu, 메모리, 디스크, 네트워크 등을 할당하고 프로세스, Users 등을 분리할 수 있었다. 하지만 리눅스 컨테이너는 프로세스 단위로 분리한 것 외엔 실제 운영 시 활용할 수준에 이르지 못했다. 그래서 등장한게 바로 도커(Docker)이다.일단 도커를 알기 전에 우리는 가상머신(VM)에 대해 먼저 알고 갈 필요가 있다. 가상머신(Virtual Machine)란?컴퓨터 안에 존재하는 또 다른 컴퓨터, 하나의 호스트에 다수의 운영체제를 생성하는 방식이다.각 운영체제 하나 하나를 가상 머신이라는 단위로 부른다. 대표적으로 VirtualBox, VMWare, Hyper-V, Parallels 등이 존재한다. 위 이미지는 가상머신과 도커의 기본적인 구조로 차이점을 쉽게 알 수 있을 것이다. 가상 머신은 호스트 운영체제 내 하이퍼바이저(가상화 기술)로 게스트 운영체제를 설치하는 구조이다.결국 게스트 운영체제 자체를 설치하기 때문에 의존 라이브러리와 커널등은 따라올 수 밖에 없게 된다.그러다보면 호스트의 많은 리소스를 할당 및 차지 하게 된다. 이에 반해 도커는 게스트 운영체제를 생성하는 것이 아닌 가상화 된 공간을 프로세스 단위로 생성한다.가상 머신과 다르게 호스트와 커널을 공유하고 컨테이너에 필요한 라이브러리만 설치하게 되는 것이다.필요한 부분만 묶어 이미지라는 단위로 배포하고 실행하므로 가상 머신에 비해 적은 리소스를 차지한다. LXC(LinuX Container, 리눅스 컨테이너)앞서 설명한 리눅스 컨테이\u001c너와 도커의 관계에 대해 궁금할 수 있다.초창기 도커의 경우 리눅스 커널 단에 포함되어 있던 리눅스 컨테이너를 활용하였다. 현재는 LibContainer 개발 프로젝트를 진행하였고 리눅스 컨테이너로부터 자유로워진 상태이다.리눅스 컨테이너가 커널단이라면 립컨테이너는 유저랜드(Userland) 라이브러리이다.","categories":[{"name":"기타","slug":"기타","permalink":"https://lee-jung-hoon.github.io/categories/기타/"},{"name":"DOCKER","slug":"기타/DOCKER","permalink":"https://lee-jung-hoon.github.io/categories/기타/DOCKER/"}],"tags":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://lee-jung-hoon.github.io/tags/DOCKER/"}]},{"title":"AOP란 무엇일까? - 01","slug":"programming-spring-study-008","date":"2018-11-05T15:50:51.000Z","updated":"2018-11-09T12:34:51.941Z","comments":true,"path":"2018/11/06/programming-spring-study-008/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/11/06/programming-spring-study-008/","excerpt":"","text":"AOP란 무엇일까?AOP는 Aspect Oriented Programming의 약자로 ‘관점 지향 프로그래밍’관심사를 분리하여 객체의 모듈화를 높히는 프로그래밍 기법이라고 생각하면 쉽다. 좀 더 어려운 말로 풀어보자면 핵심 비즈니스 로직과 공통 기능을 분리하는 기법이다. OOP 구조를 돕는 보조적인 역할을 하는 셈이다. 실제 업무 중 AOP로 활용한다면 시간과 자원을 절약할 수 있는 경우가 많다. 업무 중 있었던 에피소드를 하나 소개해볼까 한다. 위는 간단하 예시이지만 ASIS -&gt; TOBE로의 데이터 이행 작업을 해야했다. 123456789/** * 게시글 이행 Class */public class TrnsBoard implements TrnsBase &#123; @Override public void startContent() &#123; &#125;&#125; 123456789/** * 방문자 기록 이행 Class */public class TrnsVisit implements TrnsBase &#123; @Override public void startContent() &#123; &#125;&#125; 이와 같은 게시글, 방문자 기록 이행 클래스가 존재한다고 가정해보자.이때 실제 이행 이전에 예상 시간 및 정확한 이행을 위해 시간 측정은 필수이다. 하지만 해당 코드는 큰 문제점을 가지고 있다.그것은 바로 중복되는 소스로 인해 유연한 로직을 구현할 수 없다는 점이다. 만약 시간 측정 방식을 바꾸거나 해당 로그 표기 방법을 바꿔야한다면 프로젝트 내 해당 소스가 반영된 모든 메소드를 수정해야한다. 바로 관심사의 분리에 실패한 코드인 것이다. 이러한 구조를 조금 개선해볼 수 있을 것이다. 123456789101112131415161718192021/** * 프록시 객체 */public class TrnsProxy implements TrnsBase &#123; private TrnsBase target; /** * 생성자 초기화 클래스 */ public TrnsProxy(TrnsBase target) &#123; this.target = target; &#125; @Override public startContent() &#123; long sTime = System.currentTimeMillis(); target.startContent(); // 이행 long eTime = System.currentTimeMillis(); System.out.println(\"수행 시간 : \" + (eTime - sTime)); &#125;&#125; 또 다른 클래스를 생성하여 게시글, 방문자 이행와 같이 ‘TrnsBase’라는 인터페이스를 상속받아 구현한다.다른 점이라면 생성자를 통해 또다른 구현 클래스를 전달 받고 실행시간을 출력하는 동작과 핵심 로직을 동시에 수행한다는 점이다. 이로써 핵심 기능은 다른 객체에서 수행하고 공통 기능만을 제공하게 되었다.이러한 객체를 프록시 객체라 부르며 AOP의 핵심인 공통 기능과 핵심 기능을 분리할 수 있다. 이렇게 핵심 기능과 공통 기능을 분리하여 삽입하는 방법은 크게 3가지가 존재한다. 컴파일 전에 별도 컴파일러를 통해 핵심 기능 사이에 공통 기능을 삽입하여 최종 바이너리를 만드는 방식(AspectJ) 클래스 로딩 시, 별도의 에이전트를 이용하여 JVM이 클래스를 로딩하는 시점에 해당 클래스의 바이너리를 수정하여 삽입하는 방식(AspctWerkz) 런타임 시, 프록시 객체를 생성하여 핵심 로직을 구현한 객체에 접근하는 방식(Spring AOP) 각 방법별로 장단점이 존재하겠지만 간단히 살펴본다면 컴파일 시 타겟 파일을 수정하거나 클래스 로딩 시 바이너리를 가로채 조작하는 방법은 프록시 객체를 별도로 생성할 필요가 없으며 적용할 수 있는 시점이 다양하므로 자유롭다는 장점을 가지고 있다.(프록시 방식은 객체가 생성된 이후)하지만 바이너리 코드를 변경하기 위해선 클래스를 로드하는 JVM에 옵션 설정이 필요하며 별도의 에이전트가 필요하다는 단점이 존재한다. 스프링에서는 프록시를 이용한 AOP방식을 지원한다. 대부분의 기능은 프록시 방식으로 충분히 구현이 가능하며 이보다 더 깊은 기능을 필요로 할때 바이너리를 조작하는 방법을 사용하는 것이 좋다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"AOP","slug":"AOP","permalink":"https://lee-jung-hoon.github.io/tags/AOP/"}]},{"title":"스프링 자바를 이용한 주입 설정","slug":"programming-spring-study-007","date":"2018-10-20T12:01:23.000Z","updated":"2018-10-24T03:55:18.538Z","comments":true,"path":"2018/10/20/programming-spring-study-007/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/20/programming-spring-study-007/","excerpt":"","text":"1.자바를 이용한 설정그동안 XML을 이용한 의존 자동 주입을 살펴봤다.스프링은 이 외에도 자바를 이용한 주입 설정을 지원한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"스프링 DI(의존주입)-4","slug":"programming-spring-study-006","date":"2018-10-04T14:01:23.000Z","updated":"2018-10-08T14:59:40.000Z","comments":true,"path":"2018/10/04/programming-spring-study-006/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/04/programming-spring-study-006/","excerpt":"","text":"1.의존 자동 주입-2바로 앞 포스트에서 Autowired 어노테이션을 이용한 의존 객체 자동 주입을 알게 되었다.스프링은 Autowired 외에도 Resource 어노테이션을 이용한 자동 주입을 지원한다. Autowired가 타입을 이용하는 반면 Resource는 빈의 이름을 이용한다는 차이점이 있다. Autowired와 사용 방법에서 많은 차이는 없다. 설정 XML 내에 &lt;context:annotation-config/&gt; 추가 의존 주입 대상에 @Resource 어노테이션 작성 하지만 큰 차이점이 존재하는데Autowired와 다르게 생성자에는 적용할 수 없다는 점이다.그 외에 필드나 설정 메소드에는 동일하게 적용할 수 있다. 필드 자동 주입 123456789public calss MemberRegisterService &#123; @Resource(name=\"memberDao\") private MemberDao memberDao; // 의존 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; ...&#125; 설정 메소드 자동 주입 123456789public calss MemberPrinter &#123; private MemberPrinter printer; @Resource(name=\"memberPrint\") public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; 위와 같이 필드와 설정 메소드에 설정할 수 있다. Autowired와 동일하게 의존 객체를 자동 주입할 경우 constructor-arg나 property 태그를 사용하지 않아도 된다. 12345&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.MemberDao\"&gt;&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 설정 XML에 Bean을 등록하고 id 속성을 Resource 어노테이션의 name 속성과 매핑해준다. 2. Resource의 기본적인 특성Resource는 Autowired와 다르게 빈의 이름을 기준으로 주입한다고 설명했다.만약 Resource 어노테이션의 name 속성을 설정하지 않는다면 어떻게 될까? 답은 Autowired와 같이 동일한 유형을 찾아 주입한다.Autowired와 동작 순서가 반대인 셈이다.Resource 또한 name 속성이 없고 동일 유형의 빈이 다수 존재한다면 Exception이 발생한다. 3. Resource의 동작 순서Autowired와 반대 순서로 동작하는 Resource 동작 순서를 정리한다.스프링에서 Resource 어노테이션 추가 시, 동작하는 순서는 아래와 같다. name 속성 값과 동일한 빈 객체를 찾고 해당 객체를 사용한다. name 속성 값이 없을 경우, 동일 타입의 객체를 검색하고 1개일 경우, 해당 객체를 사용한다. name 속성 값이 없고 동일 타입을 갖는 빈 객체가 2개 이상일 경우, 이름이 같은 빈 객체를 찾는다. name 속성 값이 없고 동일 타입을 갖는 빈 객체가 2개 이상이면서 같은 이름을 가진 빈 객체가 없는 경우 @Qualifier(한정자) 값의 빈 객체를 찾는다. 모두 해당하지 않으면 Exception이 발생한다. 4. 자동 주입과 명시적 의존 주입 간의 관계자동 주입과 명시적 의존 주입(constructor-arg, property 태그)을 함께 사용할 수 있다.이러한 경우 자동 주입보다 명시적 의존 주입을 우선한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"스프링 DI(의존주입)-3","slug":"programming-spring-study-005","date":"2018-10-03T12:09:43.000Z","updated":"2018-10-08T14:01:00.000Z","comments":true,"path":"2018/10/03/programming-spring-study-005/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/10/03/programming-spring-study-005/","excerpt":"","text":"1.의존 자동 주입-1스프링은 프레임워크 자체에서 자동으로 의존 객체를 찾아 주입해주는 기능을 지원한다.설정 방법 또한 간단하다. 설정 XML 내에 &lt;context:annotation-config/&gt; 추가 의존 주입 대상에 @Autowired 어노테이션 작성 @Autowired 어노테이션을 이용한 의존 자동 주입에도 여러가지 방법이 존재한다. 생성자 자동 주입123456789public calss MemberRegisterService &#123; private MemberDao memberDao; @Autowired public MemberRegisterService(MemberDao memberDao) &#123; // 의존 주입 this.memberDao = memberDao; &#125; ...&#125; 위와 같이 생성자에 @Autowired 어노테이션을 추가하여 의존 객체를 자동 주입할 수 있다. 필드 자동 주입123456789public calss MemberRegisterService &#123; @Autowired private MemberDao memberDao; // 의존 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; ...&#125; 이와 같이 필드에 @Autowired 어노테이션을 추가하는 방법이 있다. 설정 메소드 자동 주입123456789public calss MemberPrinter &#123; private MemberPrinter printer; @Autowired public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; 마지막으로 설정 메소드에 어노테이션을 추가하는 방법도 있다. 이와 같은 방법으로 의존 객체를 자동 주입할 경우 앞서 사용했던 constructor-arg나 property 태그를 사용하지 않아도 된다. 12345&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.MemberRegisterService\"&gt;&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 2. Autowired의 기본적인 특성그렇다면 스프링은 어떻게 객체를 자동으로 주입할 수 있을까?우선 스프링은 같은 유형에 속하는 빈 객체를 검색해 주입 대상을 선택한다.예를 들어 B라는 클래스는 A를 상속 받아 만들어졌다고 가정하자B 클래스가 Bean에 등록되있으면서 A 클래스를 생성/설정하는 생성자 혹은 필드, 설정 메소드에 Autowired 어노테이션을 추가한다면B 클래스는 A 클래스를 상속 받아 생성된 같은 유형이므로 B 클래스를 자동 할당해준다. 만약 동일한 유형의 빈 객체 두 개가 등록 되어 있다면 어떻게 될까?이런 경우 어떤 클래스를 할지 판단할 수 없어 ‘NoUniqueBeanDefinitionException’이 발생한다. 이러한 문제를 해결하기 위해 @Qualifier 어노테이션을 사용할 수 있다. 3. Qualifier를 이용한 의존 주입 객체 선택Qualifier 어노테이션을 이용하면 동일한 유형의 클래스 다수가 Bean에 등록되어 있더라도 주입할 의존 객체를 개별적으로 선택할 수 있다. 설정 XML 내 등록 된 Bean에 한정자 태그(qualifier)와 값을 설정한다. Autowired 적용 대상에 Qualifier을 추가하고 한정자 값을 입력한다. 1234567&lt;context:annotation-config/&gt; // Autowired 처리&lt;bean id=\"memberPrinter\" class=\"kr.co.jhdev.MemberPrinter\"&gt; &lt;qualifier value=\"sysout\" /&gt; // 한정자 값 설정&lt;/bean&gt; // Bean 등록&lt;bean id=\"memberPrinter2\" class=\"kr.co.jhdev.MemberPrinter\"&gt;&lt;/bean&gt; // Bean 등록 위와 같이 동일한 유형의 객체가 Bean에 등록한 후 한정자 값을 설정한다. 12345678910public calss MemberPrinter &#123; private MemberPrinter printer; @Autowired @Qualifier(\"sysout\") public void setPrinter(MemberPrinter printer) &#123; // 의존 주입 this.printer = printer; &#125; ...&#125; Autowired 어노테이션과 함께 Qualifier 어노테이션을 기입하면 객체를 선택 주입할 수 있다. 한정자 값을 잘못 기입하면 Exception을 발생시키니 유의해야한다. 4. Autowired 필수 여부 지정만약 Autowired 어노테이션을 추가했지만 Bean이 등록되어 있지 않다면 어떻게 될까?당연하게도 스프링 컨테이너 생성 시, Exception이 발생한다. 이를 막기 위해 Autowired 어노테이션의 required(필수) 여부를 변경할 수 있다. 12345public calss MemberPrinter &#123; @Autowired(required=false) private MemberPrinter printer; // 의존 주입했지만 Bean이 등록되지 않았다. ...&#125; 위와 같이 필수 여부를 false 처리할 경우 컨테이너 생성 시, Exception이 발생하지 않는다.하지만 이는 필수 여부이지 의존 객체를 주입하지 않는다는 의미는 아니다.required=false로 처리했더라도 같은 유형의 객체가 등록되어 있다면 객체는 자동 주입된다.단순히 객체가 존재하지 않아도 Exception을 발생시키지 않는 설정이라고 생각하면 편하다. 5. Autowired의 동작 순서Autowired의 기본적인 특성에 대해 알아봤으며 마지막으로 동작 순서로 정리한다.스프링에서 Autowired 어노테이션 추가 시, 동작하는 순서는 아래와 같다. 동일 타입의 객체를 검색하고 1개일 경우, 해당 객체를 사용한다.Qualifier가 입력된 경우 Qualifier 설정 값이 동일한 빈을 찾는다. 타입이 같은 빈이 2개 이상일 경우, Qualifier 설정 값이 동일한 빈을 찾는다. 타입이 같은 빈이 2개 이상이며 Qualifier 설정 값이 없는 경우,이름이 같은 빈 객체를 찾는다. 모두 해당하지 않으면 Exception이 발생한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"}]},{"title":"프로퍼티(Property)란?","slug":"programming-spring-study-004","date":"2018-09-18T14:46:16.000Z","updated":"2018-10-03T15:46:02.000Z","comments":true,"path":"2018/09/18/programming-spring-study-004/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/18/programming-spring-study-004/","excerpt":"","text":"프로퍼티(Property)란?프로퍼티를 알기 전에 자바빈을 알아야 한다.자바빈즈은 JavaBean 규약에 따라 작성된 자바 클래스이다.자바빈즈 규약은 재사용 가능한 객체를 빈(Bean)으로 명명하고 있다. 자바빈 클래스 외부에서 필드에 접근할 경우 반드시 메소드를 통해 접근해야한다.여기서 프로퍼티는 객체와 관련하여 이름 붙여진 속성을 말하며 빈이 관리하는 데이터를 의미한다. 프로퍼티 값을 구하는 메소드는 get으로 시작한다. 프로퍼티 값을 변경하는 메소드는 set으로 시작한다. get과 set 뒤에는 프로퍼티의 이름 첫 글자를 대문자로 바꾼다. set 메소드는 1개의 파라미터를 갖는다. 프로퍼티는 위와 같은 명명 규칙을 가지고 있으며 흔히들 getter/settet를 묶어서 그냥 프로퍼티라고 부른다. 자바빈즈의 빈과 스프링의 빈은 같은 것으로 스프링의 빈이 자바빈즈의 빈을 따라한 것이다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"PROPERTY","slug":"PROPERTY","permalink":"https://lee-jung-hoon.github.io/tags/PROPERTY/"}]},{"title":"스프링 DI(의존주입)-2","slug":"programming-spring-study-003","date":"2018-09-18T12:46:16.000Z","updated":"2018-10-03T15:45:28.000Z","comments":true,"path":"2018/09/18/programming-spring-study-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/18/programming-spring-study-003/","excerpt":"","text":"1. 스프링에서의 의존주입 방식 생성자 방식 기본적인 의존주입 방식은 ‘생성자 방식’이 있다.생성자를 통해 의존 객체를 주입 받아 필드에 할당하는 방식이다.123456789101112131415public class MemberRegisterService &#123; private MemberDao memberDao; // 의존 객체를 할당해줄 생성자 메소드 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public void regist(RegisterRequest req) &#123; // 주입 받은 의존 객체를 메소드에서 사용함 Member member = memberDao.selecetByEmail(req.getEmail()); ... memberDao.insert(newMember); &#125;&#125; 12345&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;constructor-arg ref=\"memberDao\" /&gt;&lt;/bean&gt; 위와 같이 constructor-arg 태그를 이용해 생성자에 의존 객체를 주입한다.만약 생성자에 전달해야할 의존 객체가 두 개 이상이라면 constructor-arg 태그를 순서에 맞게 추가하고 생성자의 매개변수를 추가한다. 1234567891011public class MemberRegisterService &#123; private MemberDao memberDao; private MemberPrint memberPrint; // 의존 객체를 할당해줄 생성자 메소드 public MemberRegisterService(MemberDao memberDao, MemberPrint memberPrint) &#123; this.memberDao = memberDao; this.memberPrint = memberPrint; &#125; ...&#125; 1234567&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;constructor-arg ref=\"memberDao\" /&gt; &lt;constructor-arg ref=\"memberPrint\" /&gt;&lt;/bean&gt; 설정 메소드 방식 다음으로는 ‘설정 메소드 방식’이 있다.set으로 시작하는 프로퍼티 설정 메서드를 통해 의존 객체를 주입하는 방식이다.** 프로퍼티에 대한 내용은 별도로 포스트 12345678910111213public class MemberRegisterService &#123; private MemberDao memberDao; private MemberPrint memberPrint; public void setMemberDao(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public void setMemberPrint(MemberPrint memberPrint) &#123; this.memberPrint = memberPrint; &#125; ...&#125; 1234567&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;property ref=\"memberDao\" name=\"memberDao\"/&gt; &lt;property ref=\"memberPrint\" name=\"memberPrint\"/&gt;&lt;/bean&gt; 설정 메소드 방식은 각 필드의 getter/setter를 가지며 태그를 이용해 객체를 주입한다. 그렇다면 이 두 가지 방식 중 어떤 방식이 좋은 방식일까? 결론은 양쪽 모두 장단점이 존재한다. 생성자 방식은 빈 객체 생성 시점에 모든 의존 객체가 주입되지만주입해야할 객체가 많을 경우 생성자의 파라미터가 많아지고 가독성이 떨어진다. 반대로 설정 메소드 방식은 property 태그의 name 속성(attribute)를 통해해당 의존 객체에 대해 알아볼 수 있으므로 가독성이 좋은 편이다. 하지만 설정 메소드 방식의 경우 property 태그가 누락될 경우 객체 사용 시점에 NullPointException을 발생 시킬 수 있다. 2. 객체 주입 시 기본 값 설정생성자 방식과 설정 메소드 방식을 통해 의존 객체를 주입하는 방법을 알 수 있었다.이와 같은 객체 주입 시 기본 데이터 값을 설정해야하는 경우 value 속성을 이용한다. 123456789101112131415161718public class VersionPrint &#123; private int majorVersion; private int minorVersion; // setter public void setMajorVersion(int majorVersion) &#123; this.majorVersion = majorVersion; &#125; // setter public void setMinorVersion(int minorVersion) &#123; this.minorVersion = minorVersion; &#125; public void print() &#123; System.out.println(\"Version Num : \" + majorVersion + \".\" + minorVersion); &#125;&#125; 123456&lt;bean id=\"versionPrint\" class=\"kr.co.jhdev.Version.versionPrint\"&gt; &lt;property name=\"majorVersion\" value=\"3\"/&gt; &lt;property name=\"minorVersion\"&gt; &lt;value&gt;7&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 생성자, 설정 메소드 두 방식 모두 value 속성을 통해 기본 값을 설정한다.value 속성이 아닌 태그를 통해 중첩 사용하는 방법도 존재한다. 여기서 주목해야할 점은 해당 기본 값의 데이터 타입을 알 수 없음에도 정상 동작한다.그 이유는 스프링이 알아서 데이터 타입으로 변환하여 처리하기 때문이다. 3. 두 개 이상의 설정파일 사용하기개발을 하다보면 설정 관련 파일이 비대해질 수 있다.이럴 경우 가독성도 떨어지게 되고 유지보수에 있어 어려움을 겪을 수 있다. 해당 문제점을 개선하기 위해선 설정 파일을 성격에 따라 나누어야 한다.설정 파일을 나눈 경우 GenericXmlApplicationContext 클래스의 생성자를 이용하는 방법과 import 태그를 이용하는 방법이 있다. GenericXmlApplicationContext의 생성자를 이용하는 방식기본적으로 GenericXmlApplicationContext 클래스의 생성자는 가변 인자이므로 배열을 이용할 수 있다. 12String[] conf = &#123;\"classpath:conf1.xml\", \"classpath:conf2.xml\"&#125;;ctx = new GenericXmlApplicationContext(conf) 위와 같이 설정 xml 파일 경로를 배열에 담고 생성자에 전달하는 방식이다. import 태그를 이용하는 방식import 태그를 이용하는 방식의 경우 설정파일을 분리 한 후 import 태그를 이용해한 설정 파일에 다른 설정 파일 내용을 삽입해주는 방법이다. 123456789&lt;import resource=\"classpath:conf2.xml /&gt;&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.Member.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"memberPrint\" class=\"kr.co.jhdev.Member.MemberPrint\"&gt;&lt;/bean&gt;&lt;bean id=\"memberRegSvc\" class=\"kr.co.jhdev.Member.MemberRegisterService\"&gt; &lt;property ref=\"memberDao\" name=\"memberDao\"/&gt; &lt;property ref=\"memberPrint\" name=\"memberPrint\"/&gt;&lt;/bean&gt; 위와 같이 설정 파일 내용을 import 태그를 통해 다른 설정 파일에 추가하여 함께 사용할 수 있다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"IOC","slug":"IOC","permalink":"https://lee-jung-hoon.github.io/tags/IOC/"}]},{"title":"서비스 로케이터란?","slug":"programming-java-servicelocator-002","date":"2018-09-16T06:22:44.000Z","updated":"2018-09-16T07:10:00.000Z","comments":true,"path":"2018/09/16/programming-java-servicelocator-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/programming-java-servicelocator-002/","excerpt":"","text":"스프링을 공부하던 중 의존 해결을 위한 방법으로 서비스 로케이터와 DI가 있다고 배웠다. 하지만 서비스 로케이터를 제대로 설명하는 경우는 별로 없는듯 하다. 많은 부분에서 알지는 못하지만 이해한 곳까지는 적어보려 한다. 서비스 로케이터(Service Locator)는 마틴 파울러에 의해 유명해진 디자인 패턴이다. JNDI를 생각하면 빠르게 이해할 수 있을 듯 하다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceLocator &#123; private InitialContext ic; private Map cache; private static ServiceLocator me; static &#123; me = new ServiceLocator(); &#125; private SerivceLocator() &#123; cache = Collections.synchronizedMap(new HashMap()); &#125; public InitialContext getInitialContext() throws Exception &#123; try&#123; if( ic == null) &#123; ic = new InitialContext(); &#125; &#125; catch (Exception e) &#123; throw e; &#125; return ic; &#125; public static ServiceLocator getInstance()&#123; return me; &#125; public EJBLocalHome getLocalHome(String jndiHomeName) throws Exception &#123; EJBLocalHome home = null; try&#123; if (cache.containsKey(jndiHomeName)) &#123; home = (EJBLocalHome)cache.get(jndiHomeName); &#125; else&#123; home = (EJBLocalHome)getInitialContext().lookup(jndiHomeName); cache.put(jndiHomeName, home); &#125; &#125; catch (NamingException ne) &#123; throw new Exception(ne.getMessage()); &#125; catch (Exception e) &#123; throw new Exception(e.getMessage()); &#125; return home; &#125;&#125;; 서비스 로케이터 패턴은 위의 소스와 같이 cache에 담아두고 객체가 필요할 경우메모리에서 바로바로 찾아서 제공하는 구조를 가진다. cache에서 키를 찾아 존재하는 경우, 반환하고 없는 경우 cache에 담아주는 형태를 가진다. 인용 https://code.i-harness.com/ko-kr/q/17c515Dependency Injection과 Service Locator의 차이점은 무엇입니까? 두 패턴 모두 종속성 반전 원리를 구현하는 데 적합합니다. Service Locator 패턴은 공용 인터페이스를 변경하지 않고 전체 디자인을 느슨하게 만들기 때문에 기존 코드베이스에서 사용하기가 더 쉽습니다. 이와 동일한 이유로 Service Locator 패턴을 기반으로하는 코드는 Dependency Injection을 기반으로하는 동일한 코드보다 읽기 쉽지 않습니다. Dependency Injection 패턴은 클래스 (또는 메소드)가 가질 종속성 서명 이후에 명확하게 나타냅니다. 이러한 이유로 결과 코드는보다 깨끗하고 읽기 쉽습니다. 읽어 볼만한 링크http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"DeginePattern","slug":"DeginePattern","permalink":"https://lee-jung-hoon.github.io/tags/DeginePattern/"},{"name":"ServiceLocator","slug":"ServiceLocator","permalink":"https://lee-jung-hoon.github.io/tags/ServiceLocator/"}]},{"title":"JEUS8, WEBTOB5 라이센스 적용 방법","slug":"was-jeus-license-001","date":"2018-09-16T01:51:08.000Z","updated":"2018-09-16T04:30:22.000Z","comments":true,"path":"2018/09/16/was-jeus-license-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/was-jeus-license-001/","excerpt":"","text":"해당 문서는 JEUS와 웹투비 라이센스 파일을 발급 받은 상태를 전제로 합니다. JEUS 라이센스 적용 방법 JEUS 설치 경로로 이동합니다. ($JEUS_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license license.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. jeusadmin 명령어를 이용하여 라이센스 정보를 확인합니다. jeusadmin -licensedue jeusadmin -licenseinfo JEUS를 재기동합니다. jdown -&gt; jboot 라이센스 파일은 .dat 확장자로 되어있을 경우 확장자를 제거하여야 합니다. ftp를 이용하여 업로드 하기 이전에 확장자를 제거할 한 후 업로드 할 경우 디렉토리로 인식하므로 업로드 후 확장자를 제거합니다. (cp license.dat license) Demo 라이센스의 경우 licensedue 명령어 입력 시, ‘ㅇㅇ Days Left’라는 유효기간에 대한 코멘트가 나타나며, 정식 라이센스의 경우 ‘unlimited’ 코멘트가 나타납니다. Demo 라이센스의 경우 licenseinfo 명령어 입력 시, Edition 부분에 ‘Demo License’ 문구가 나타나며 CPU가 ‘unlimited’라 출력됩니다. 정식 라이센스의 경우 ‘Demo’ 문구가 없으며 신청한 CPU 코어수와 HOST NAME이 나타납니다. JEUS 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. manager server를 shutdown 상태로 전환하고nodemanager down -&gt; das down -&gt; das boot -&gt; nodemanager boot 순으로 진행합니다. WEBTOB 라이센스 적용 방법 WEBTOB 설치 경로로 이동합니다. ($WEBTOB_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license.dat license.dat.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. wsconfig 파일을 컴파일 합니다.($WEBTOB_HOME/config 경로에서 ‘wscfl -i http.m’) wsadmin 명령어를 이용하여 라이센스 정보를 확인합니다. wsadmin -i [라이센스 파일명] WEBTOB를 재기동합니다. wsdown -&gt; wsboot wsadmin 명령어를 이용하여 적용된 라이센스 정보를 확인합니다. wsadmin 입력 후 wi 재 입력 JEUS와 달리 .dat 확장자 그대로 적용합니다. wsadmin -i [라이센스 파일명] 입력 시, License Type이 ‘DEMO’로 출력될 경우 데모 라이센스이며 정식 라이센스인 경우 ‘REAL’이 출력됩니다. WEBTOB 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. wsadmin 입력 후 wi 재 입력 시, Demo 라이센스의 경우 ‘DEMO’라 출력되며 정식 라이센스인 경우 ‘REAL’이 출력됩니다.","categories":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/"},{"name":"JEUS","slug":"WAS/JEUS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/JEUS/"}],"tags":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/tags/WAS/"},{"name":"JEUS","slug":"JEUS","permalink":"https://lee-jung-hoon.github.io/tags/JEUS/"},{"name":"WEBTOB","slug":"WEBTOB","permalink":"https://lee-jung-hoon.github.io/tags/WEBTOB/"},{"name":"LICENSE","slug":"LICENSE","permalink":"https://lee-jung-hoon.github.io/tags/LICENSE/"}]},{"title":"maven-4.0.0.xsd에서 에러날 경우","slug":"programming-spring-error-003","date":"2018-09-09T12:59:01.000Z","updated":"2018-09-16T04:02:50.000Z","comments":true,"path":"2018/09/09/programming-spring-error-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-error-003/","excerpt":"","text":"pom.xml 프로젝트 태그 내 maven-4.0.0.xsd에서 에러가 발생할 경우위와 같은 에러가 발생할 경우 https://mvnrepository.com/artifact/org.apache.maven/maven-plugin-api 해당 URL에 접속하여 안정적인 버전의 maven dependency를 복사하여 pom.xml에 추가합니다. 해당 프로젝트 오른쪽 우클릭 -&gt; Run As -&gt; Maven Clean, Maven Install 실행 해당 프로젝트 오른쪽 우클릭 -&gt; Maven -&gt; Update Project(Alt + F5) 실행","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"MAVEN","slug":"MAVEN","permalink":"https://lee-jung-hoon.github.io/tags/MAVEN/"}]},{"title":"JDK 설치 및 환경변수 설정","slug":"programming-java-install-001","date":"2018-09-09T11:42:02.000Z","updated":"2018-09-09T14:49:32.000Z","comments":true,"path":"2018/09/09/programming-java-install-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-java-install-001/","excerpt":"","text":"1. JDK의 계층 구조 JVM(JAVA Virtual Machine) 자바 가성 머신의 줄임말으로써 JAVA와 OS의 중개자 역할을 한다. JVM이 있으므로 인해 자바는 OS에 구애받지 않는 ‘확장성’이라는 장점을 가지게 된다. 그 외에도 가비지 컬렉션(Garbage Collection), 메모리 관리등을 수행한다. JRE(JAVA Runtime Environment) 자바의 기능들을 수행하는 API를 감싸고 있는 실행환경 단순 프로그램 실행만을 위해서는 JRE 설치로 충분하다. JDK(JAVA Development Kit) 자바의 실행환경을 포함하는 자바 개발환경을 의미한다. 자바 개발을 위해서는 JDK가 설치되어야 한다. 2. JDK 설치http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 상단의 JDK SE 다운로드 URL에 접속하여 본인 개발 환경에 맞는 설치파일을 다운로드 및 설치를 진행한다. 3. JAVA 환경변수 java.exe : JVM 실행 파일 javac.exe : 컴파일러 JAVA_HOME 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 변수 이름 : JAVA_HOME 변수 값 : JAVA 설치 경로 PATH 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 PATH 변수에 %JAVA_HOME%\\bin을 추가 JAVA_HOME 변수에 설정한 JAVA 설치 경로 하위의 bin 폴더를 PATH 추가해주는 것입니다.** 리눅스나 유닉스 계열은 profile에 설정 4. 확인 명령 프롬프트에 ‘java -version’, ‘javac -version’를 입력하여 버젼을 확인한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"JDK - JRE - JVM","slug":"JDK-JRE-JVM","permalink":"https://lee-jung-hoon.github.io/tags/JDK-JRE-JVM/"}]},{"title":"스프링 DI(의존 주입)","slug":"programming-spring-study-002","date":"2018-09-09T09:46:16.000Z","updated":"2018-09-16T09:06:48.000Z","comments":true,"path":"2018/09/09/programming-spring-study-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-002/","excerpt":"","text":"스프링의 DI(의존 주입)을 보기 전에 먼저 스프링의 목적을 알아볼 필요가 있다. 2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제 ‘무엇때문에 자바 엔터프라이즈 프로젝트는 실패하는가?’ 그에 대한 답은 바로 시스템 개발이 복잡하다는 것이었다. 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리하는 시스템 이러한 시스템은 비즈니스 로직 구현만이 아닌 보안, 안정성, 확장성, 성능을 모두 고려해서 개발해야한다. 결국 비즈니스 로직, 안정성, 확장성, 성능에 더해 추후 바뀔지 모르는 비즈니스 로직에 대한 유지보수 및 수정까지 고려해야하는 큰 어려움에 부딪혔다 1. 의존이란 DI(Dependency Infjection) 의존 관계 주입이라는 말로 해석 할 수 있다. 표준국어대사전에 의하면 ‘의존’이란 다른 것에 의지하여 존재하는 즉, 의존관계란 변경에 의해 영향을 받는 관계를 의미한다. 1234567891011121314151617public class MemberRegisterService &#123; // new 연산자를 이용해서 MemeberDao의 인스턴스를 생성한다. 이를 '보통객체'라 부른다. private MemberDao memberDao = new MemberDao(); public void regist(RegisterRequest req) &#123; // 이메일로 회원 데이터(Member)조회 Member member = memberDao.selectByEmail(req.getEmail()); if (member != null) &#123; // 같은 이메일을 가진 회원이 이미 존재하면 익셉션 발생 throw new AlreadyExistingMemberException(\"dup email : \" + req.getEmail()); &#125; // 같은 이메일을 가진 회원이 존재하지 않으면 DB에 삽입 Member newMember = new Member(req.getEmail(), req.getPassword(), req.getName(), new Date()); memberDao.insert(newMember); &#125;&#125; 위 코드는 전달 받은 회원 객체 내 이메일 주소가 현재 회원 DB 테이블 내에 존재하는 경우익셉션을 발생시키고 같은 이메일 주소를 가진 회원이 존재하지 않는 경우 DB에 INSERT 시키는 간단한 로직을 가지고 있다. 이와 같이 한 클래스에서 다른 클래스의 메소드를 실행하는 경우를 ‘의존’한다고 말한다. 의존은 변경에 의해 영향을 받는 관계를 의미한다. ex) MembaerDao의 insert()메소드의 이름을 insertMemeber()라고 변경하면 이 메소드를 사용하는 타 클래스들도 영향을 받는다. 여기서 알고 가면 좋은 한 가지.객체지향 프로그래밍의 기초 개념 중 하나는 관심사의 분리 라는 것이다. 단순히 DB INSERT하고 SELECT하는 메소드를 만들때 위와 같은 코드를 만들 수 있지만리소스의 낭비나 환경의 변화에 바로 대응하기 위해선 관심사의 분리가 중요하다. 1234567891011121314151617public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Class.forName(\"oracle.jdbc.driver.OracleDriver\"); Connection c = DriverManager.getConnection( \"jdbc:oracle:thin:@127.0.0.1:1521:orcl\", \"PPS_DB\", \"PPS123\"); return c;&#125; ...public void add(User user) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; public void get(String id) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; 위와 같이 중복 혹은 의존 관계인 코드를 분리하여 의존을 제거할 수 있다.DB의 종류가 바뀌거나 계정을 바꿔야할 경우 getConnection 메소드만 수정하면 끝! 의존 객체를 구하는 방법에는 DI와 서비스 로케이터가 있다. 서비스 로케이터에 관련하여 별도로 포스트 예정 DI는 의존하는 객체를 직접 생성하지 않고 의존 객체를 전달받는 방식을 사용한다. 12345678910111213Member dao = new MemberDao();// 의존 객체를 생성자를 통해 주입처리MemberRegisterService service = new MemberRegisterService(dao);...public class MemberRegisterService &#123; private MemberDao memberDao; // MemberRegisterServeice가 의존하고 있는 MemberDao 객체를 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125;...&#125; 위와 같이 의존 객체를 직접 생성하지 않고 생성자를 통해 전달 받으므로 DI(의존 주입) 패턴을 따르고 있다. 12345678910111213public static void main(String[] args) &#123; MemberAssembler assembler = new MemberAssembler(); Member member = new Member(\"jh4327\", \"4327\"); RegisterService registerService = assembler.getRegisterService(); registerService.register(member); member.setPassword(\"1234\"); PwChangeService pwChangeService = assembler.getPwChangeService(); pwChangeService.update(member);&#125; 위와 같이 사용자를 입력하고 비밀번호를 수정하는 구조를 가진 프로세스가 있을 때 1234567891011121314151617181920212223242526272829303132333435public class MemberAssembler &#123; private MemberDao memberDao; private RegisterService registerService; private PwChangeService pwChangeService; public MemberAssembler() &#123; memberDao = new MemberDao(); registerService = new RegisterService(memberDao); pwChangeService = new PwChangeService(memberDao); &#125; public MemberDao getMemberDao() &#123; return memberDao; &#125; public void setMemberDao(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public RegisterService getRegisterService() &#123; return registerService; &#125; public void setRegisterService(RegisterService registerService) &#123; this.registerService = registerService; &#125; public PwChangeService getPwChangeService() &#123; return pwChangeService; &#125; public void setPwChangeService(PwChangeService pwChangeService) &#123; this.pwChangeService = pwChangeService; &#125;&#125; 위와 같은 객체 조립기를 통해 DAO 의존 주입이 가능하다.하나의 동일한 객체를 각 서비스에 주입시켜주는 구조.최초 생성(로드)할 때 DAO 객체를 다른 객체가 생성될 때 모두 주입하는 것이다.즉 Service들은 Dao에 의존하고 있으며 의존 주입 관계이다. 이걸 스프링 DI로 변경한다면?123456789&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"registerService\" class=\"kr.co.jhdev.MemberService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"pwChangeService\" class=\"kr.co.jhdev.PwChangeService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 앞서 개발한 객체 조립기를 xml 스프링 컨테이너로 변경한다.registerService와 pwChangeService는 memberDao를 참조하도록 한다.이로써 최초 로드시 서비스들과 dao의 의존관계가 설정된다. 1234567891011121314// MemberAssembler assembler = new MemberAssembler();GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:applicationContext.xml\");Member member = new Member(\"jh4327\", \"4327\");// RegisterService registerService = assembler.getRegisterService();RegisterService registerService = ctx.getBean(\"registerService\", RegisterService.class);registerService.register(member);member.setPassword(\"1234\");// PwChangeService pwChangeService = assembler.getPwChangeService();PwChangeService pwChangeService = ctx.getBean(\"pwChangeService\", PwChangeService.class);pwChangeService.update(member); 스프링 컨테이너에 등록한 bean과 객체들 간 의존 관계를 이용하여 위와 같은 코드로 변경될 수 있다.직접 주입하지 않고 스프링 컨테이너를 통해 주입하고 getBean을 통해 불러오기만 하면 된다.지금까진 xml을 이용한 의존 주입을 해왔다. 다음 해당 포스팅에선 어노테이션을 이용한 방법에 대해 설명하도록 한다. 결국 의존 주입은 관심사의 분리를 통해 유지보수와 수정을 용이하게 하기 위함에 목적이 있다. 초보 웹 개발자를 위한 스프링 4 프로그래밍 입문(최범균 지음) 토비의 스프링 3.1(이일민 지음)","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"IOC","slug":"IOC","permalink":"https://lee-jung-hoon.github.io/tags/IOC/"}]},{"title":"java-spring-study-001","slug":"programming-spring-study-001","date":"2018-09-09T09:46:11.000Z","updated":"2018-09-09T11:46:40.000Z","comments":true,"path":"2018/09/09/programming-spring-study-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-001/","excerpt":"","text":"","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[]},{"title":"테이블스페이스 용량 확인 쿼리","slug":"dbms-oracle-tablespace-001","date":"2018-09-09T09:26:25.000Z","updated":"2018-09-09T09:49:52.000Z","comments":true,"path":"2018/09/09/dbms-oracle-tablespace-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/dbms-oracle-tablespace-001/","excerpt":"","text":"업무를 하다보면 계정의 테이블스페이스의 현재 상태를 체크해야할 일이 생깁니다. 예를 들어 데이터를 이관해야하는 경우, AUTOEXTENSIBLE가 YES일지라도 테이블스페이스의 현재 상태는 체크해주는게 좋습니다. 123456789101112131415SELECT SUBSTR(A.TABLESPACE_NAME,1,30) TABLESPACE, ROUND(SUM(A.TOTAL1)/1024/1024,1) \"총 용량(MB)\", ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1) \"사용량(MB)\", ROUND(SUM(A.SUM1)/1024/1024,1) \"잔여용량(MB)\", ROUND((ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1))/ROUND(SUM(A.TOTAL1)/1024/1024,1)*100,2) \"사용률(%)\"FROM (SELECT TABLESPACE_NAME,0 TOTAL1,SUM(BYTES) SUM1,MAX(BYTES) MAXB,COUNT(BYTES) CNT FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME UNION SELECT TABLESPACE_NAME,SUM(BYTES) TOTAL1,0,0,0 FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME) AGROUP BY A.TABLESPACE_NAMEORDER BY TABLESPACE; 해당 쿼리 실행 시 총 용량과 현재 사용량, 잔여용량, 사용률 등을 확인할 수 있습니다.","categories":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/"},{"name":"ORACLE","slug":"DBMS/ORACLE","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/ORACLE/"}],"tags":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/tags/DBMS/"},{"name":"ORACLE","slug":"ORACLE","permalink":"https://lee-jung-hoon.github.io/tags/ORACLE/"},{"name":"TABLESPACE","slug":"TABLESPACE","permalink":"https://lee-jung-hoon.github.io/tags/TABLESPACE/"}]}]}