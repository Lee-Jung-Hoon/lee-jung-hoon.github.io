{"meta":{"title":"DevJH","subtitle":"Writed by JH, IT Blog","description":"IT Blog","author":"Lee Jung Hoon","url":"https://lee-jung-hoon.github.io"},"pages":[],"posts":[{"title":"서비스 로케이터란?","slug":"programming-java-servicelocator-002","date":"2018-09-16T06:22:44.000Z","updated":"2018-09-16T07:09:58.051Z","comments":true,"path":"2018/09/16/programming-java-servicelocator-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/programming-java-servicelocator-002/","excerpt":"","text":"스프링을 공부하던 중 의존 해결을 위한 방법으로 서비스 로케이터와 DI가 있다고 배웠다. 하지만 서비스 로케이터를 제대로 설명하는 경우는 별로 없는듯 하다. 많은 부분에서 알지는 못하지만 이해한 곳까지는 적어보려 한다. 서비스 로케이터(Service Locator)는 마틴 파울러에 의해 유명해진 디자인 패턴이다. JNDI를 생각하면 빠르게 이해할 수 있을 듯 하다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ServiceLocator &#123; private InitialContext ic; private Map cache; private static ServiceLocator me; static &#123; me = new ServiceLocator(); &#125; private SerivceLocator() &#123; cache = Collections.synchronizedMap(new HashMap()); &#125; public InitialContext getInitialContext() throws Exception &#123; try&#123; if( ic == null) &#123; ic = new InitialContext(); &#125; &#125; catch (Exception e) &#123; throw e; &#125; return ic; &#125; public static ServiceLocator getInstance()&#123; return me; &#125; public EJBLocalHome getLocalHome(String jndiHomeName) throws Exception &#123; EJBLocalHome home = null; try&#123; if (cache.containsKey(jndiHomeName)) &#123; home = (EJBLocalHome)cache.get(jndiHomeName); &#125; else&#123; home = (EJBLocalHome)getInitialContext().lookup(jndiHomeName); cache.put(jndiHomeName, home); &#125; &#125; catch (NamingException ne) &#123; throw new Exception(ne.getMessage()); &#125; catch (Exception e) &#123; throw new Exception(e.getMessage()); &#125; return home; &#125;&#125;; 서비스 로케이터 패턴은 위의 소스와 같이 cache에 담아두고 객체가 필요할 경우메모리에서 바로바로 찾아서 제공하는 구조를 가진다. cache에서 키를 찾아 존재하는 경우, 반환하고 없는 경우 cache에 담아주는 형태를 가진다. 인용 https://code.i-harness.com/ko-kr/q/17c515Dependency Injection과 Service Locator의 차이점은 무엇입니까? 두 패턴 모두 종속성 반전 원리를 구현하는 데 적합합니다. Service Locator 패턴은 공용 인터페이스를 변경하지 않고 전체 디자인을 느슨하게 만들기 때문에 기존 코드베이스에서 사용하기가 더 쉽습니다. 이와 동일한 이유로 Service Locator 패턴을 기반으로하는 코드는 Dependency Injection을 기반으로하는 동일한 코드보다 읽기 쉽지 않습니다. Dependency Injection 패턴은 클래스 (또는 메소드)가 가질 종속성 서명 이후에 명확하게 나타냅니다. 이러한 이유로 결과 코드는보다 깨끗하고 읽기 쉽습니다. 읽어 볼만한 링크http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"DeginePattern","slug":"DeginePattern","permalink":"https://lee-jung-hoon.github.io/tags/DeginePattern/"},{"name":"ServiceLocator","slug":"ServiceLocator","permalink":"https://lee-jung-hoon.github.io/tags/ServiceLocator/"}]},{"title":"JEUS8, WEBTOB5 라이센스 적용 방법","slug":"was-jeus-license-001","date":"2018-09-16T01:51:08.000Z","updated":"2018-09-16T04:30:21.805Z","comments":true,"path":"2018/09/16/was-jeus-license-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/16/was-jeus-license-001/","excerpt":"","text":"해당 문서는 JEUS와 웹투비 라이센스 파일을 발급 받은 상태를 전제로 합니다. JEUS 라이센스 적용 방법 JEUS 설치 경로로 이동합니다. ($JEUS_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license license.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. jeusadmin 명령어를 이용하여 라이센스 정보를 확인합니다. jeusadmin -licensedue jeusadmin -licenseinfo JEUS를 재기동합니다. jdown -&gt; jboot 라이센스 파일은 .dat 확장자로 되어있을 경우 확장자를 제거하여야 합니다. ftp를 이용하여 업로드 하기 이전에 확장자를 제거할 한 후 업로드 할 경우 디렉토리로 인식하므로 업로드 후 확장자를 제거합니다. (cp license.dat license) Demo 라이센스의 경우 licensedue 명령어 입력 시, ‘ㅇㅇ Days Left’라는 유효기간에 대한 코멘트가 나타나며, 정식 라이센스의 경우 ‘unlimited’ 코멘트가 나타납니다. Demo 라이센스의 경우 licenseinfo 명령어 입력 시, Edition 부분에 ‘Demo License’ 문구가 나타나며 CPU가 ‘unlimited’라 출력됩니다. 정식 라이센스의 경우 ‘Demo’ 문구가 없으며 신청한 CPU 코어수와 HOST NAME이 나타납니다. JEUS 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. manager server를 shutdown 상태로 전환하고nodemanager down -&gt; das down -&gt; das boot -&gt; nodemanager boot 순으로 진행합니다. WEBTOB 라이센스 적용 방법 WEBTOB 설치 경로로 이동합니다. ($WEBTOB_HOME/license) 기존 라이센스 파일을 백업처리 합니다. (cp license.dat license.dat.old) ftp를 이용하여 신규 라이센스 파일을 업로드합니다. wsconfig 파일을 컴파일 합니다.($WEBTOB_HOME/config 경로에서 ‘wscfl -i http.m’) wsadmin 명령어를 이용하여 라이센스 정보를 확인합니다. wsadmin -i [라이센스 파일명] WEBTOB를 재기동합니다. wsdown -&gt; wsboot wsadmin 명령어를 이용하여 적용된 라이센스 정보를 확인합니다. wsadmin 입력 후 wi 재 입력 JEUS와 달리 .dat 확장자 그대로 적용합니다. wsadmin -i [라이센스 파일명] 입력 시, License Type이 ‘DEMO’로 출력될 경우 데모 라이센스이며 정식 라이센스인 경우 ‘REAL’이 출력됩니다. WEBTOB 재기동 이전에 반드시 정식 라이센스의 CPU 코어 수, HOST NAME이 실제와 일치하는지 확인합니다. wsadmin 입력 후 wi 재 입력 시, Demo 라이센스의 경우 ‘DEMO’라 출력되며 정식 라이센스인 경우 ‘REAL’이 출력됩니다.","categories":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/"},{"name":"JEUS","slug":"WAS/JEUS","permalink":"https://lee-jung-hoon.github.io/categories/WAS/JEUS/"}],"tags":[{"name":"WAS","slug":"WAS","permalink":"https://lee-jung-hoon.github.io/tags/WAS/"},{"name":"JEUS","slug":"JEUS","permalink":"https://lee-jung-hoon.github.io/tags/JEUS/"},{"name":"WEBTOB","slug":"WEBTOB","permalink":"https://lee-jung-hoon.github.io/tags/WEBTOB/"},{"name":"LICENSE","slug":"LICENSE","permalink":"https://lee-jung-hoon.github.io/tags/LICENSE/"}]},{"title":"maven-4.0.0.xsd에서 에러날 경우","slug":"programming-spring-error-003","date":"2018-09-09T12:59:01.000Z","updated":"2018-09-16T04:02:49.746Z","comments":true,"path":"2018/09/09/programming-spring-error-003/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-error-003/","excerpt":"","text":"pom.xml 프로젝트 태그 내 maven-4.0.0.xsd에서 에러가 발생할 경우위와 같은 에러가 발생할 경우 https://mvnrepository.com/artifact/org.apache.maven/maven-plugin-api 해당 URL에 접속하여 안정적인 버전의 maven dependency를 복사하여 pom.xml에 추가합니다. 해당 프로젝트 오른쪽 우클릭 -&gt; Run As -&gt; Maven Clean, Maven Install 실행 해당 프로젝트 오른쪽 우클릭 -&gt; Maven -&gt; Update Project(Alt + F5) 실행","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"MAVEN","slug":"MAVEN","permalink":"https://lee-jung-hoon.github.io/tags/MAVEN/"}]},{"title":"JDK 설치 및 환경변수 설정","slug":"programming-java-install-001","date":"2018-09-09T11:42:02.000Z","updated":"2018-09-09T14:49:31.975Z","comments":true,"path":"2018/09/09/programming-java-install-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-java-install-001/","excerpt":"","text":"1. JDK의 계층 구조 JVM(JAVA Virtual Machine) 자바 가성 머신의 줄임말으로써 JAVA와 OS의 중개자 역할을 한다. JVM이 있으므로 인해 자바는 OS에 구애받지 않는 ‘확장성’이라는 장점을 가지게 된다. 그 외에도 가비지 컬렉션(Garbage Collection), 메모리 관리등을 수행한다. JRE(JAVA Runtime Environment) 자바의 기능들을 수행하는 API를 감싸고 있는 실행환경 단순 프로그램 실행만을 위해서는 JRE 설치로 충분하다. JDK(JAVA Development Kit) 자바의 실행환경을 포함하는 자바 개발환경을 의미한다. 자바 개발을 위해서는 JDK가 설치되어야 한다. 2. JDK 설치http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 상단의 JDK SE 다운로드 URL에 접속하여 본인 개발 환경에 맞는 설치파일을 다운로드 및 설치를 진행한다. 3. JAVA 환경변수 java.exe : JVM 실행 파일 javac.exe : 컴파일러 JAVA_HOME 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 변수 이름 : JAVA_HOME 변수 값 : JAVA 설치 경로 PATH 설정 내컴퓨터 -&gt; 속성 -&gt; 고급시스템설정 -&gt; 고급 -&gt; 환경변수 -&gt; 새로만들기 PATH 변수에 %JAVA_HOME%\\bin을 추가 JAVA_HOME 변수에 설정한 JAVA 설치 경로 하위의 bin 폴더를 PATH 추가해주는 것입니다.** 리눅스나 유닉스 계열은 profile에 설정 4. 확인 명령 프롬프트에 ‘java -version’, ‘javac -version’를 입력하여 버젼을 확인한다.","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"JAVA","slug":"PROGRAMMING/JAVA","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://lee-jung-hoon.github.io/tags/JAVA/"},{"name":"JDK - JRE - JVM","slug":"JDK-JRE-JVM","permalink":"https://lee-jung-hoon.github.io/tags/JDK-JRE-JVM/"}]},{"title":"스프링 DI(의존 주입)","slug":"programming-spring-study-002","date":"2018-09-09T09:46:16.000Z","updated":"2018-09-16T09:06:47.311Z","comments":true,"path":"2018/09/09/programming-spring-study-002/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-002/","excerpt":"","text":"스프링의 DI(의존 주입)을 보기 전에 먼저 스프링의 목적을 알아볼 필요가 있다. 2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제 ‘무엇때문에 자바 엔터프라이즈 프로젝트는 실패하는가?’ 그에 대한 답은 바로 시스템 개발이 복잡하다는 것이었다. 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리하는 시스템 이러한 시스템은 비즈니스 로직 구현만이 아닌 보안, 안정성, 확장성, 성능을 모두 고려해서 개발해야한다. 결국 비즈니스 로직, 안정성, 확장성, 성능에 더해 추후 바뀔지 모르는 비즈니스 로직에 대한 유지보수 및 수정까지 고려해야하는 큰 어려움에 부딪혔다 1. 의존이란 DI(Dependency Infjection) 의존 관계 주입이라는 말로 해석 할 수 있다. 표준국어대사전에 의하면 ‘의존’이란 다른 것에 의지하여 존재하는 즉, 의존관계란 변경에 의해 영향을 받는 관계를 의미한다. 1234567891011121314151617public class MemberRegisterService &#123; // new 연산자를 이용해서 MemeberDao의 인스턴스를 생성한다. 이를 '보통객체'라 부른다. private MemberDao memberDao = new MemberDao(); public void regist(RegisterRequest req) &#123; // 이메일로 회원 데이터(Member)조회 Member member = memberDao.selectByEmail(req.getEmail()); if (member != null) &#123; // 같은 이메일을 가진 회원이 이미 존재하면 익셉션 발생 throw new AlreadyExistingMemberException(\"dup email : \" + req.getEmail()); &#125; // 같은 이메일을 가진 회원이 존재하지 않으면 DB에 삽입 Member newMember = new Member(req.getEmail(), req.getPassword(), req.getName(), new Date()); memberDao.insert(newMember); &#125;&#125; 위 코드는 전달 받은 회원 객체 내 이메일 주소가 현재 회원 DB 테이블 내에 존재하는 경우익셉션을 발생시키고 같은 이메일 주소를 가진 회원이 존재하지 않는 경우 DB에 INSERT 시키는 간단한 로직을 가지고 있다. 이와 같이 한 클래스에서 다른 클래스의 메소드를 실행하는 경우를 ‘의존’한다고 말한다. 의존은 변경에 의해 영향을 받는 관계를 의미한다. ex) MembaerDao의 insert()메소드의 이름을 insertMemeber()라고 변경하면 이 메소드를 사용하는 타 클래스들도 영향을 받는다. 여기서 알고 가면 좋은 한 가지.객체지향 프로그래밍의 기초 개념 중 하나는 관심사의 분리 라는 것이다. 단순히 DB INSERT하고 SELECT하는 메소드를 만들때 위와 같은 코드를 만들 수 있지만리소스의 낭비나 환경의 변화에 바로 대응하기 위해선 관심사의 분리가 중요하다. 1234567891011121314151617public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Class.forName(\"oracle.jdbc.driver.OracleDriver\"); Connection c = DriverManager.getConnection( \"jdbc:oracle:thin:@127.0.0.1:1521:orcl\", \"PPS_DB\", \"PPS123\"); return c;&#125; ...public void add(User user) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; public void get(String id) throws ClassNotFoundException, SQLException &#123; Connection c = getConnection(); ... &#125; 위와 같이 중복 혹은 의존 관계인 코드를 분리하여 의존을 제거할 수 있다.DB의 종류가 바뀌거나 계정을 바꿔야할 경우 getConnection 메소드만 수정하면 끝! 의존 객체를 구하는 방법에는 DI와 서비스 로케이터가 있다. 서비스 로케이터에 관련하여 별도로 포스트 예정 DI는 의존하는 객체를 직접 생성하지 않고 의존 객체를 전달받는 방식을 사용한다. 12345678910111213Member dao = new MemberDao();// 의존 객체를 생성자를 통해 주입처리MemberRegisterService service = new MemberRegisterService(dao);...public class MemberRegisterService &#123; private MemberDao memberDao; // MemberRegisterServeice가 의존하고 있는 MemberDao 객체를 주입 public MemberRegisterService(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125;...&#125; 위와 같이 의존 객체를 직접 생성하지 않고 생성자를 통해 전달 받으므로 DI(의존 주입) 패턴을 따르고 있다. 12345678910111213public static void main(String[] args) &#123; MemberAssembler assembler = new MemberAssembler(); Member member = new Member(\"jh4327\", \"4327\"); RegisterService registerService = assembler.getRegisterService(); registerService.register(member); member.setPassword(\"1234\"); PwChangeService pwChangeService = assembler.getPwChangeService(); pwChangeService.update(member);&#125; 위와 같이 사용자를 입력하고 비밀번호를 수정하는 구조를 가진 프로세스가 있을 때 1234567891011121314151617181920212223242526272829303132333435public class MemberAssembler &#123; private MemberDao memberDao; private RegisterService registerService; private PwChangeService pwChangeService; public MemberAssembler() &#123; memberDao = new MemberDao(); registerService = new RegisterService(memberDao); pwChangeService = new PwChangeService(memberDao); &#125; public MemberDao getMemberDao() &#123; return memberDao; &#125; public void setMemberDao(MemberDao memberDao) &#123; this.memberDao = memberDao; &#125; public RegisterService getRegisterService() &#123; return registerService; &#125; public void setRegisterService(RegisterService registerService) &#123; this.registerService = registerService; &#125; public PwChangeService getPwChangeService() &#123; return pwChangeService; &#125; public void setPwChangeService(PwChangeService pwChangeService) &#123; this.pwChangeService = pwChangeService; &#125;&#125; 위와 같은 객체 조립기를 통해 DAO 의존 주입이 가능하다.하나의 동일한 객체를 각 서비스에 주입시켜주는 구조.최초 생성(로드)할 때 DAO 객체를 다른 객체가 생성될 때 모두 주입하는 것이다.즉 Service들은 Dao에 의존하고 있으며 의존 주입 관계이다. 이걸 스프링 DI로 변경한다면?123456789&lt;bean id=\"memberDao\" class=\"kr.co.jhdev.MemberDao\"&gt;&lt;/bean&gt;&lt;bean id=\"registerService\" class=\"kr.co.jhdev.MemberService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"pwChangeService\" class=\"kr.co.jhdev.PwChangeService\"&gt; &lt;constructor-arg ref=\"memberDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 앞서 개발한 객체 조립기를 xml 스프링 컨테이너로 변경한다.registerService와 pwChangeService는 memberDao를 참조하도록 한다.이로써 최초 로드시 서비스들과 dao의 의존관계가 설정된다. 1234567891011121314// MemberAssembler assembler = new MemberAssembler();GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:applicationContext.xml\");Member member = new Member(\"jh4327\", \"4327\");// RegisterService registerService = assembler.getRegisterService();RegisterService registerService = ctx.getBean(\"registerService\", RegisterService.class);registerService.register(member);member.setPassword(\"1234\");// PwChangeService pwChangeService = assembler.getPwChangeService();PwChangeService pwChangeService = ctx.getBean(\"pwChangeService\", PwChangeService.class);pwChangeService.update(member); 스프링 컨테이너에 등록한 bean과 객체들 간 의존 관계를 이용하여 위와 같은 코드로 변경될 수 있다.직접 주입하지 않고 스프링 컨테이너를 통해 주입하고 getBean을 통해 불러오기만 하면 된다.지금까진 xml을 이용한 의존 주입을 해왔다. 다음 해당 포스팅에선 어노테이션을 이용한 방법에 대해 설명하도록 한다. 결국 의존 주입은 관심사의 분리를 통해 유지보수와 수정을 용이하게 하기 위함에 목적이 있다. 초보 웹 개발자를 위한 스프링 4 프로그래밍 입문(최범균 지음) 토비의 스프링 3.1(이일민 지음)","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[{"name":"SPRING","slug":"SPRING","permalink":"https://lee-jung-hoon.github.io/tags/SPRING/"},{"name":"DI","slug":"DI","permalink":"https://lee-jung-hoon.github.io/tags/DI/"},{"name":"IOC","slug":"IOC","permalink":"https://lee-jung-hoon.github.io/tags/IOC/"}]},{"title":"java-spring-study-001","slug":"programming-spring-study-001","date":"2018-09-09T09:46:11.000Z","updated":"2018-09-09T11:46:39.702Z","comments":true,"path":"2018/09/09/programming-spring-study-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/programming-spring-study-001/","excerpt":"","text":"","categories":[{"name":"PROGRAMMING","slug":"PROGRAMMING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/"},{"name":"SPRING","slug":"PROGRAMMING/SPRING","permalink":"https://lee-jung-hoon.github.io/categories/PROGRAMMING/SPRING/"}],"tags":[]},{"title":"테이블스페이스 용량 확인 쿼리","slug":"dbms-oracle-tablespace-001","date":"2018-09-09T09:26:25.000Z","updated":"2018-09-09T09:49:51.331Z","comments":true,"path":"2018/09/09/dbms-oracle-tablespace-001/","link":"","permalink":"https://lee-jung-hoon.github.io/2018/09/09/dbms-oracle-tablespace-001/","excerpt":"","text":"업무를 하다보면 계정의 테이블스페이스의 현재 상태를 체크해야할 일이 생깁니다. 예를 들어 데이터를 이관해야하는 경우, AUTOEXTENSIBLE가 YES일지라도 테이블스페이스의 현재 상태는 체크해주는게 좋습니다. 123456789101112131415SELECT SUBSTR(A.TABLESPACE_NAME,1,30) TABLESPACE, ROUND(SUM(A.TOTAL1)/1024/1024,1) \"총 용량(MB)\", ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1) \"사용량(MB)\", ROUND(SUM(A.SUM1)/1024/1024,1) \"잔여용량(MB)\", ROUND((ROUND(SUM(A.TOTAL1)/1024/1024,1)-ROUND(SUM(A.SUM1)/1024/1024,1))/ROUND(SUM(A.TOTAL1)/1024/1024,1)*100,2) \"사용률(%)\"FROM (SELECT TABLESPACE_NAME,0 TOTAL1,SUM(BYTES) SUM1,MAX(BYTES) MAXB,COUNT(BYTES) CNT FROM DBA_FREE_SPACE GROUP BY TABLESPACE_NAME UNION SELECT TABLESPACE_NAME,SUM(BYTES) TOTAL1,0,0,0 FROM DBA_DATA_FILES GROUP BY TABLESPACE_NAME) AGROUP BY A.TABLESPACE_NAMEORDER BY TABLESPACE; 해당 쿼리 실행 시 총 용량과 현재 사용량, 잔여용량, 사용률 등을 확인할 수 있습니다.","categories":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/"},{"name":"ORACLE","slug":"DBMS/ORACLE","permalink":"https://lee-jung-hoon.github.io/categories/DBMS/ORACLE/"}],"tags":[{"name":"DBMS","slug":"DBMS","permalink":"https://lee-jung-hoon.github.io/tags/DBMS/"},{"name":"ORACLE","slug":"ORACLE","permalink":"https://lee-jung-hoon.github.io/tags/ORACLE/"},{"name":"TABLESPACE","slug":"TABLESPACE","permalink":"https://lee-jung-hoon.github.io/tags/TABLESPACE/"}]}]}